<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue源码分析 | 叫我詹躲躲</title>
    <meta name="description" content="  ">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/favicon.ico">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.3b6aa6d6.css" as="style"><link rel="preload" href="/assets/js/app.86b73e6f.js" as="script"><link rel="preload" href="/assets/js/3.58a7fd54.js" as="script"><link rel="preload" href="/assets/js/1.4b4254a2.js" as="script"><link rel="preload" href="/assets/js/31.8e9e1642.js" as="script"><link rel="prefetch" href="/assets/js/10.24bdfd64.js"><link rel="prefetch" href="/assets/js/11.c9f497bb.js"><link rel="prefetch" href="/assets/js/12.be8018c1.js"><link rel="prefetch" href="/assets/js/13.c98c4450.js"><link rel="prefetch" href="/assets/js/14.083760ef.js"><link rel="prefetch" href="/assets/js/15.114fbf56.js"><link rel="prefetch" href="/assets/js/16.7f3ec64a.js"><link rel="prefetch" href="/assets/js/17.cc2f24d1.js"><link rel="prefetch" href="/assets/js/18.15ff37a4.js"><link rel="prefetch" href="/assets/js/19.f5f52531.js"><link rel="prefetch" href="/assets/js/20.3809f72b.js"><link rel="prefetch" href="/assets/js/21.103a0a5e.js"><link rel="prefetch" href="/assets/js/22.15027d01.js"><link rel="prefetch" href="/assets/js/23.2a93fe1a.js"><link rel="prefetch" href="/assets/js/24.79f8d04e.js"><link rel="prefetch" href="/assets/js/25.8694d728.js"><link rel="prefetch" href="/assets/js/26.c2f19c81.js"><link rel="prefetch" href="/assets/js/27.cc62cb5d.js"><link rel="prefetch" href="/assets/js/28.2951c0c2.js"><link rel="prefetch" href="/assets/js/29.2cfb586f.js"><link rel="prefetch" href="/assets/js/30.bf4b25ce.js"><link rel="prefetch" href="/assets/js/32.8f1c2a6c.js"><link rel="prefetch" href="/assets/js/33.f3daa276.js"><link rel="prefetch" href="/assets/js/34.517ad1f5.js"><link rel="prefetch" href="/assets/js/35.0e914192.js"><link rel="prefetch" href="/assets/js/36.8915466a.js"><link rel="prefetch" href="/assets/js/37.d188ec12.js"><link rel="prefetch" href="/assets/js/38.3063f900.js"><link rel="prefetch" href="/assets/js/39.1e1bf8e7.js"><link rel="prefetch" href="/assets/js/4.3db7564a.js"><link rel="prefetch" href="/assets/js/40.ffab515e.js"><link rel="prefetch" href="/assets/js/5.2bb44786.js"><link rel="prefetch" href="/assets/js/6.5f61ae1d.js"><link rel="prefetch" href="/assets/js/7.3192c400.js"><link rel="prefetch" href="/assets/js/8.47f2af46.js"><link rel="prefetch" href="/assets/js/9.2071ed24.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3b6aa6d6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="theme-container" data-v-4698c43e><div data-v-4698c43e><div id="loader-wrapper" class="loading-wrapper" data-v-4b73742e data-v-4698c43e data-v-4698c43e><div class="loader-main" data-v-4b73742e><div data-v-4b73742e></div><div data-v-4b73742e></div><div data-v-4b73742e></div><div data-v-4b73742e></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-6cbeab0a data-v-4698c43e data-v-4698c43e><h3 class="title" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a>叫我詹躲躲</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><input type="password" value="" data-v-6cbeab0a> <span data-v-6cbeab0a>Konck! Knock!</span> <button data-v-6cbeab0a>OK</button></label> <div class="footer" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><span data-v-6cbeab0a><i class="iconfont reco-theme" data-v-6cbeab0a></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-6cbeab0a>vuePress-theme-reco</a></span> <span data-v-6cbeab0a><i class="iconfont reco-copyright" data-v-6cbeab0a></i> <a data-v-6cbeab0a><span data-v-6cbeab0a>叫我詹躲躲</span>
            
          <span data-v-6cbeab0a>2019 - </span>
          2020
        </a></span></div></div> <div class="hide" data-v-4698c43e><header class="navbar" data-v-4698c43e><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="叫我詹躲躲" class="logo"> <span class="site-name">叫我詹躲躲</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/前端笔记/" class="nav-link"><i class="iconfont undefined"></i>
  前端笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/半夏梦境/" class="nav-link"><i class="iconfont undefined"></i>
  半夏梦境
</a></li><li class="dropdown-item"><!----> <a href="/categories/学习文档/" class="nav-link"><i class="iconfont undefined"></i>
  学习文档
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/views/前端生态.html" class="nav-link"><i class="iconfont reco-coding"></i>
  components
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/zhanhongzhu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.jianshu.com/u/ceba9a1ce95b" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-jianshu"></i>
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://zhanhongzhu.gitee.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-blog"></i>
  个人网站
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://juejin.im/user/5cc6757ce51d456e5238ca23" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-juejin"></i>
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-wechat"></i>
  公众号
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/zhanhongzhu/dashboard" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  G码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-4698c43e></div> <aside class="sidebar" data-v-4698c43e><div class="personal-info-wrapper" data-v-6c8ffc9c><img src="/avatar.jpg" alt="author-avatar" class="personal-img" data-v-6c8ffc9c> <h3 class="name" data-v-6c8ffc9c>
    叫我詹躲躲
  </h3> <div class="num" data-v-6c8ffc9c><div data-v-6c8ffc9c><h3 data-v-6c8ffc9c>24</h3> <h6 data-v-6c8ffc9c>文章</h6></div> <div data-v-6c8ffc9c><h3 data-v-6c8ffc9c>11</h3> <h6 data-v-6c8ffc9c>标签</h6></div></div> <hr data-v-6c8ffc9c></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/前端笔记/" class="nav-link"><i class="iconfont undefined"></i>
  前端笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/半夏梦境/" class="nav-link"><i class="iconfont undefined"></i>
  半夏梦境
</a></li><li class="dropdown-item"><!----> <a href="/categories/学习文档/" class="nav-link"><i class="iconfont undefined"></i>
  学习文档
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/views/前端生态.html" class="nav-link"><i class="iconfont reco-coding"></i>
  components
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/zhanhongzhu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.jianshu.com/u/ceba9a1ce95b" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-jianshu"></i>
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://zhanhongzhu.gitee.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-blog"></i>
  个人网站
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://juejin.im/user/5cc6757ce51d456e5238ca23" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-juejin"></i>
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-wechat"></i>
  公众号
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/zhanhongzhu/dashboard" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  G码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue源码分析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#基本原则" class="sidebar-link">基本原则</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#替换-vnode" class="sidebar-link">替换 VNode</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#更新标签元素" class="sidebar-link">更新标签元素</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#更新标签元素的基本原则" class="sidebar-link">更新标签元素的基本原则</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#更新-vnodedata" class="sidebar-link">更新 VNodeData</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#更新子节点" class="sidebar-link">更新子节点</a></li></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#更新文本节点" class="sidebar-link">更新文本节点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#更新-fragment" class="sidebar-link">更新 Fragment</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#更新-portal" class="sidebar-link">更新 Portal</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#有状态组件的更新" class="sidebar-link">有状态组件的更新</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#主动更新" class="sidebar-link">主动更新</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#初步了解组件的外部状态-props" class="sidebar-link">初步了解组件的外部状态 props</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#被动更新" class="sidebar-link">被动更新</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#我们需要-shouldupdatecomponent" class="sidebar-link">我们需要 shouldUpdateComponent</a></li></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#函数式组件的更新" class="sidebar-link">函数式组件的更新</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#减小dom操作的性能开销" class="sidebar-link">减小DOM操作的性能开销</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#尽可能的复用-dom-元素" class="sidebar-link">尽可能的复用 DOM 元素</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#key-的作用" class="sidebar-link">key 的作用</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#找到需要移动的节点" class="sidebar-link">找到需要移动的节点</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#移动节点" class="sidebar-link">移动节点</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#添加新元素" class="sidebar-link">添加新元素</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#移除不存在的元素" class="sidebar-link">移除不存在的元素</a></li></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#另一个思路-双端比较" class="sidebar-link">另一个思路 - 双端比较</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#双端比较的原理" class="sidebar-link">双端比较的原理</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#双端比较的优势" class="sidebar-link">双端比较的优势</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#非理想情况的处理方式" class="sidebar-link">非理想情况的处理方式</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#添加新元素-2" class="sidebar-link">添加新元素</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#移除不存在的元素-2" class="sidebar-link">移除不存在的元素</a></li></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#inferno-所采用的核心-diff-算法及原理" class="sidebar-link">inferno 所采用的核心 Diff 算法及原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#相同的前置和后置元素" class="sidebar-link">相同的前置和后置元素</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#判断是否需要进行-dom-移动" class="sidebar-link">判断是否需要进行 DOM 移动</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#dom-移动的方式" class="sidebar-link">DOM 移动的方式</a></li><li class="sidebar-sub-header"><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#求解最长递增子序列" class="sidebar-link">求解最长递增子序列</a></li></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#不足之处" class="sidebar-link">不足之处</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#自定义渲染器的原理" class="sidebar-link">自定义渲染器的原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#自定义渲染器的应用" class="sidebar-link">自定义渲染器的应用</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-6cbeab0a data-v-4698c43e><h3 class="title" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a>vue源码分析</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><input type="password" value="" data-v-6cbeab0a> <span data-v-6cbeab0a>Konck! Knock!</span> <button data-v-6cbeab0a>OK</button></label> <div class="footer" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><span data-v-6cbeab0a><i class="iconfont reco-theme" data-v-6cbeab0a></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-6cbeab0a>vuePress-theme-reco</a></span> <span data-v-6cbeab0a><i class="iconfont reco-copyright" data-v-6cbeab0a></i> <a data-v-6cbeab0a><span data-v-6cbeab0a>叫我詹躲躲</span>
            
          <span data-v-6cbeab0a>2019 - </span>
          2020
        </a></span></div></div> <div data-v-4698c43e><main class="page"><!----> <div class="page-title" style="display:none;"><h1>vue源码分析</h1> <hr> <div data-v-484a899e><i class="iconfont reco-account" data-v-484a899e><span data-v-484a899e>叫我詹躲躲</span></i> <i class="iconfont reco-date" data-v-484a899e><span data-v-484a899e>2020-03-02</span></i> <i class="iconfont reco-eye" data-v-484a899e><span id="/views/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/1.vue/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-484a899e><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-484a899e><span class="tag-item" data-v-484a899e>
      vue
    </span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener noreferrer">转载:非商用-文章原地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h1 id="渲染器之patch"><a href="#渲染器之patch" class="header-anchor">#</a> 渲染器之patch</h1> <p>在上一章中我们讲解并实现了渲染器的挂载逻辑，本质上就是将各种类型的 <code>VNode</code> 渲染成真实DOM的过程。渲染器除了将全新的 <code>VNode</code> 挂载成真实DOM之外，它的另外一个职责是负责对新旧 <code>VNode</code> 进行比对，并以合适的方式更新DOM，也就是我们常说的 <code>patch</code>。本章内容除了让你了解基本的比对逻辑之外，还讲述了在新旧 <code>VNode</code> 比对的过程中应该遵守怎样的原则，让我们开始吧！</p> <h2 id="基本原则"><a href="#基本原则" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 基本原则</h2> <p>通常重渲染(<code>re-render</code>)是由组件的更新开始的，因为在框架的使用层面开发者通过变更数据状态从而引起框架内部对UI的自动更新，但是组件的更新本质上还是对真实DOM的更新，或者说是对标签元素的更新，所以我们就优先来看一下如何更新一个标签元素。</p> <p>我们首先回顾一下渲染器的代码，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> container<span class="token punctuation">.</span>vnode
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 没有旧的 VNode，使用 `mount` 函数挂载全新的 VNode</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token comment">// 将新的 VNode 添加到 container.vnode 属性下，这样下一次渲染时旧的 VNode 就存在了</span>
      container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> vnode
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 有旧的 VNode，则调用 `patch` 函数打补丁</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token comment">// 更新 container.vnode</span>
      container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> vnode
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 有旧的 VNode 但是没有新的 VNode，这说明应该移除 DOM，在浏览器中可以使用 removeChild 函数。</span>
      container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
      container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>如上高亮的两句代码所示，当使用 <code>render</code> 渲染器渲染一个全新的 <code>VNode</code> 时，会调用 <code>mount</code> 函数挂载该 <code>VNode</code>，同时让容器元素存储对该 <code>VNode</code> 对象的引用，这样当再次调用渲染器渲染新的 <code>VNode</code> 对象到相同的容器元素时，由于旧的 <code>VNode</code> 已经存在，所以会调用 <code>patch</code> 函数以合适的方式进行更新，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span>

<span class="token comment">// 第一次渲染 VNode 到 #app，此时会调用 mount 函数</span>
<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 第二次渲染新的 VNode 到相同的 #app 元素，此时会调用 patch 函数</span>
<span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>patch</code> 函数会对新旧 <code>VNode</code> 进行比对，也就是我们所说的 <code>diff</code>，那么不同的两个 <code>VNode</code> 之间应该遵守怎样的比对规则呢？其实这个问题很容易回答，我们知道 <code>VNode</code> 有类型之分，不同类型的 <code>VNode</code> 之间存在一定的差异，所以不同的 <code>VNode</code> 之间第一个比对原则就是：<strong>只有相同类型的 <code>VNode</code> 才有比对的意义</strong>，例如我们有两个 <code>VNode</code>，其中一个 <code>VNode</code> 的类型是标签元素，而另一个 <code>VNode</code> 的类型是组件，当这两个 <code>VNode</code> 进行比对时，最优的做法是<strong>使用新的 <code>VNode</code> 完全替换旧的 <code>VNode</code></strong>，换句话说我们根本就没有做任何比对的操作，因为这完全没有意义，所以根据这个思想我们实现的 <code>patch</code> 函数如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 分别拿到新旧 VNode 的类型，即 flags</span>
  <span class="token keyword">const</span> nextFlags <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>flags
  <span class="token keyword">const</span> prevFlags <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>flags

  <span class="token comment">// 检查新旧 VNode 的类型是否相同，如果类型不同，则直接调用 replaceVNode 函数替换 VNode</span>
  <span class="token comment">// 如果新旧 VNode 的类型相同，则根据不同的类型调用不同的比对函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevFlags <span class="token operator">!==</span> nextFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchElement</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchComponent</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchText</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchFragment</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchPortal</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>如上代码所示，既然 <code>patch</code> 函数的作用是用来比对新旧 <code>VNode</code>，那么 <code>patch</code> 函数必然需要接收新旧 <code>VNode</code> 作为参数，我们使用 <code>prevVNode</code> 形参代表旧的 <code>VNode</code>，使用 <code>nextVNode</code> 形参代表新的 <code>VNode</code>，如上是很清晰的一段比对逻辑，首先我们需要拿到新旧 <code>VNode</code> 的类型(<code>flags</code>)，接着是一连串的 <code>if...else if</code> 语句，其核心原则是：<strong>如果类型不同，则直接调用 <code>replaceVNode</code> 函数使用新的 <code>VNode</code> 替换旧的 <code>VNode</code>，否则根据不同的类型调用与之相符的比对函数</strong>，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/flags-patch.6d43f459.png" alt="img"></p> <h2 id="替换-vnode"><a href="#替换-vnode" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9B%BF%E6%8D%A2-vnode" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 替换 VNode</h2> <p>我们首先来研究一下如何替换 <code>VNode</code>，即 <code>replaceVNode</code> 函数应该做什么，我们先来复现需要替换 <code>VNode</code> 的场景，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode 是一个 div 标签</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧的 VNode'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新的 VNode'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新的 VNode 是一个组件</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span>

<span class="token comment">// 先后渲染新旧 VNode 到 #app</span>
<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在如上代码中，我们先后渲染了新旧 <code>VNode</code> 到 <code>#app</code> 元素，由于新旧 <code>VNode</code> 具有不同的类型，所以此时会触发 <code>VNode</code> 的替换操作，替换操作并不复杂，本质就是<strong>把旧的 <code>VNode</code> 所渲染的DOM移除，再挂载新的 <code>VNode</code></strong>，如下是 <code>replaceVNode</code> 函数的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 将旧的 VNode 所渲染的 DOM 从容器中移除</span>
  container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 再把新的 VNode 挂载到容器中</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/jlxjk18vm5</p> <p><a href="https://codesandbox.io/s/jlxjk18vm5" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>看上去很简单，但实际上仅有这两行代码的话，是存在缺陷的。至于有何缺陷我们会在本章的后面讲解，因为目前我们的背景铺垫还不够。</p> <h2 id="更新标签元素"><a href="#更新标签元素" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9B%B4%E6%96%B0%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 更新标签元素</h2> <h3 id="更新标签元素的基本原则"><a href="#更新标签元素的基本原则" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9B%B4%E6%96%B0%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 更新标签元素的基本原则</h3> <p>当新旧 <code>VNode</code> 的类型不同时，会调用 <code>replaceVNode</code> 函数直接使用新的 <code>VNode</code> 替换旧的 <code>VNode</code>。但如果新旧 <code>VNode</code> 的类型相同，则会根据不同的类型调用不同的比对函数，这一小节我们就来看看如何更新一个标签元素。</p> <p>首先即使两个 <code>VNode</code> 的类型同为标签元素，但它们也可能是不同的标签，也就是说它们的 <code>tag</code> 属性值不尽相同。这就又引申出了一条更新原则：<strong>我们认为不同的标签渲染的内容不同</strong>，例如 <code>ul</code> 标签下只能渲染 <code>li</code> 标签，所以拿 <code>ul</code> 标签和一个 <code>div</code> 标签进行比对是没有任何意义的，这种情况下我们不会对旧的标签元素打补丁，而是使用新的标签元素替换旧的标签元素，这就需要用到我们前面讲过的 <code>replaceVNode</code> 函数，如下 <code>patchElement</code> 函数所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>那么如果新旧 <code>VNode</code> 描述的是相同的标签呢？如果标签相同，那两个 <code>VNode</code> 之间的差异就只会出现在 <code>VNodeData</code> 和 <code>children</code> 上了，所以对于描述相同标签的两个 <code>VNode</code> 之间的比对，本质上就是对 <code>VNodeData</code> 和 <code>children</code> 的比对，我们先来看一下如何更新 <code>VNodeData</code>，如下面两个 <code>VNode</code> 所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  style<span class="token operator">:</span> <span class="token punctuation">{</span>
    width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
    height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
    backgroundColor<span class="token operator">:</span> <span class="token string">'red'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  style<span class="token operator">:</span> <span class="token punctuation">{</span>
    width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
    height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
    border<span class="token operator">:</span> <span class="token string">'1px solid green'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>如上代码所示，新旧 <code>VNode</code> 描述的都是 <code>div</code> 标签，但是他们拥有不同的样式，旧的 <code>VNode</code> 描述的是一个红色背景的 <code>div</code>，而新的 <code>VNode</code> 描述的是拥有绿色边框的 <code>div</code>，如果仅针对这个案例而言，我们的更新规则应该是：<strong>先将红色背景从元素上移除，再为元素添加绿色边框</strong>。如果我们把问题的解决方案宏观化，就变成了：<strong>将新的 VNodeData 全部应用到元素上，再把那些已经不存在于新的 <code>VNodeData</code> 上的数据从元素上移除</strong>，根据这个思想，我们为 <code>patchElement</code> 函数增加如下高亮的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 拿到 新旧 VNodeData</span>
  <span class="token keyword">const</span> prevData <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>data
  <span class="token keyword">const</span> nextData <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
  <span class="token comment">// 新的 VNodeData 存在时才有必要更新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历新的 VNodeData</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 根据 key 拿到新旧 VNodeData 值</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">const</span> nextValue <span class="token operator">=</span> nextData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
          <span class="token comment">// 遍历新 VNodeData 中的 style 数据，将新的样式应用到元素</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 遍历旧 VNodeData 中的 style 数据，将已经不存在于新的 VNodeData 的数据移除</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextValue<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>如上高亮代码所示，我们在更新 <code>VNodeData</code> 时的思路分为以下几步：</p> <ul><li>第 1 步：当新的 <code>VNodeData</code> 存在时，遍历新的 <code>VNodeData</code>。</li> <li>第 2 步：根据新 <code>VNodeData</code> 中的 <code>key</code>，分别尝试读取旧值和新值，即 <code>prevValue</code> 和 <code>nextValue</code>。</li> <li>第 3 步：使用 <code>switch...case</code> 语句匹配不同的数据进行不同的更新操作</li></ul> <p>以样式(<code>style</code>)的更新为例，如上代码所展示的更新过程是：</p> <ul><li>1 ：遍历新的样式数据(<code>prevValue</code>)，将新的样式数据全部应用到元素上</li> <li>2 ：遍历旧的样式数据(<code>nextValue</code>)，将那些已经不存在于新的样式数据中的样式从元素上移除，最终我们完成了元素样式的更新。</li></ul> <p>这个过程实际上就是更新标签元素的基本规则。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/9l2mxjkw14</p> <p><a href="https://codesandbox.io/s/9l2mxjkw14" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="更新-vnodedata"><a href="#更新-vnodedata" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9B%B4%E6%96%B0-vnodedata" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 更新 VNodeData</h3> <p>观察我们在 <code>patchElement</code> 函数中用来更新样式的代码，大家有没有注意到似曾相识？没错，这段代码与 <code>mountElement</code> 函数内用来处理 <code>VNodeData</code> 的代码非常相似，这就指导我们封装一个函数用来统一处理 <code>VNodeData</code>，实际上无论是 <code>mountElement</code> 函数中用来处理 <code>VNodeData</code> 的代码还是 <code>patchElement</code> 函数中用来处理 <code>VNodeData</code> 的代码，它们的本质都是将 <code>VNodeData</code> 中的数据应用到 DOM 元素上，唯一的区别就是在 <code>mountElement</code> 函数中没有“旧”数据可言，而在 <code>patchElement</code> 函数中既有旧数据也有新数据，所以我们完全可以封装一个叫做 <code>patchData</code> 的函数，该函数接收新旧数据作为参数，对于 <code>mountElement</code> 函数来讲，由于它没有旧数据可言，所以在调用 <code>patchData</code> 函数时只需要传递 <code>null</code> 作为旧数据即可。</p> <p>我们先来使用 <code>patchData</code> 函数修改 <code>patchElement</code> 函数的代码，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token keyword">const</span> prevData <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>data
  <span class="token keyword">const</span> nextData <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data

  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历新的 VNodeData，将旧值和新值都传递给 patchData 函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">const</span> nextValue <span class="token operator">=</span> nextData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token function">patchData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历旧的 VNodeData，将已经不存在于新的 VNodeData 中的数据移除</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> prevData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevValue <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nextData<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第四个参数为 null，代表移除数据</span>
        <span class="token function">patchData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>如上高亮代码所示，使用 <code>patchData</code> 函数改写之后的代码变得较之前简洁了许多，核心思想没有变，仍然是：<strong>遍历新的 <code>VNodeData</code>，将旧值和新值都传递给 <code>patchData</code> 函数，并由 <code>patchData</code> 函数负责更新数据；同时也需要遍历旧的 <code>VNodeData</code>，将已经不存在于新的 <code>VNodeData</code> 中的数据从元素上移除</strong>，所以我们可以看到在遍历旧 <code>VNodeData</code> 时如果没有旧数据，或者虽然有旧数据但旧数据已经不存在于新数据上了，这时我们传递给 <code>patchData</code> 函数的第四个参数为 <code>null</code>，意味着将该数据从元素上移除。如下是 <code>patchData</code> 函数的实现，本质就是把原来 <code>patchElement</code> 函数中的 <code>switch</code> 语句块移动到了 <code>patchData</code> 函数中：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">patchData</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
      <span class="token comment">// 将新的样式数据应用到元素</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 移除已经不存在的样式</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextValue<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>当然以上 <code>patchData</code> 函数中的代码只包含对于样式(<code>style</code>)数据的处理，实际上我们可以把上一章中 <code>mountElement</code> 函数中完整的用来处理 <code>VNodeData</code> 数据的代码拷贝到 <code>patchData</code> 函数中，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">patchData</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextValue<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
    <span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
      el<span class="token punctuation">.</span>className <span class="token operator">=</span> nextValue
      <span class="token keyword">break</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'o'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 事件</span>
        el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>domPropsRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当作 DOM Prop 处理</span>
        el<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当作 Attr 处理</span>
        el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>这样 <code>patchData</code> 函数就能够用来处理 <code>style</code>、<code>class</code>、<code>DOM Prop</code> 以及 <code>Attr</code> 的更新操作，并且可以同时满足 <code>mountElement</code> 和 <code>patchElement</code> 的需求。但 <code>patchData</code> 函数还不能够满足事件的更新操作，因为当新的 <code>VNodeData</code> 中已经不包含某个事件时，我们需要将旧的事件回调函数移除，解决办法很简单，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">patchData</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
      <span class="token comment">// 省略处理样式的代码...</span>
    <span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
      <span class="token comment">// 省略处理 class 的代码...</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'o'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 事件</span>
        <span class="token comment">// 移除旧事件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> prevValue<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 添加新事件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>domPropsRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当作 DOM Prop 处理</span>
        el<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当作 Attr 处理</span>
        el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>如上高亮代码所示，如果旧的事件回调函数存在，我们先将其从 DOM 元素上移除，接着如果新的事件回调函数存在我们再将其添加到 DOM 元素中。至此我们的 <code>patchData</code> 函数就算大功告成了。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/wk8pl46o18</p> <p><a href="https://codesandbox.io/s/wk8pl46o18" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="更新子节点"><a href="#更新子节点" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 更新子节点</h3> <p>当 <code>VNodeData</code> 更新完成之后，对于新旧两个标签来说，就剩下子节点的差异了，所以我们在 <code>patchElement</code> 函数中最后一步需要做的事情就是递归地更新子节点，如下高亮的代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token keyword">const</span> prevData <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>data
  <span class="token keyword">const</span> nextData <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data

  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历新的 VNodeData，将旧值和新值都传递给 patchData 函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">const</span> nextValue <span class="token operator">=</span> nextData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token function">patchData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历旧的 VNodeData，将已经不存在于新的 VNodeData 中的数据移除</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> prevData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevValue <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nextData<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第四个参数为 null，代表移除数据</span>
        <span class="token function">patchData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 调用 patchChildren 函数递归地更新子节点</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 旧的 VNode 子节点的类型</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 新的 VNode 子节点的类型</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 旧的 VNode 子节点</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 新的 VNode 子节点</span>
    el                    <span class="token comment">// 当前标签元素，即这些子节点的父节点</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>我们在 <code>patchElement</code> 函数的最后调用了 <code>patchChildren</code> 函数，<code>patchChildren</code> 函数的作用就是对新旧 <code>VNode</code> 的子节点进行<strong>同层级</strong>的比较，它接收五个参数，前四个参数分别是新旧 <code>VNode</code> 子节点以及子节点的类型，第五个参数 <code>el</code> 是这些子节点的父节点，也就是当前被更新的标签元素。</p> <p>在开始实现同层级子节点的更新之前，需要根据我们目前掌握的知识思考一下应该如何做，<strong>思路是能够写出代码的原因</strong>。我们观察如下两个 <code>div</code> 标签的子节点，我们用 <code>VNode</code> 来表示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如上代码所示， <code>prevVNode</code> 所描述的 <code>div</code> 标签只有一个子节点，所以 <code>prevVNode</code> 的子节点类型应该是 <code>ChildrenFlags.SINGLE_VNODE</code>，而 <code>nextVNode</code> 所描述的 <code>div</code> 标签没有子节点，所以 <code>nextVNode</code> 的子节点类型应该是 <code>ChildrenFlags.NO_CHILDREN</code>。如果单纯地看这个例子，我们应该如何更新呢？很简单，我们只需要把 <code>prevVNode</code> 的子节点移除即可。再来看下面的两个 <code>VNode</code>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个例子与之前的例子恰好相反，<code>prevVNode</code> 没有子节点而 <code>nextVNode</code> 有一个子节点，所以 <code>prevVNode</code> 和 <code>nextVNode</code> 的子节点的类型分别是 <code>ChildrenFlags.NO_CHILDREN</code> 和 <code>ChildrenFlags.SINGLE_VNODE</code>，这时我们的更新操作也很简单，只需要把 <code>nextVNode</code> 的子节点挂载到 <code>div</code> 标签即可。再来看下面的例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在这个例子中，新旧 <code>div</code> 标签都有一个子节点，所以他们的子节点类型相同，这时子节点的更新操作就等价于两个子节点之间的 <code>patch</code>。</p> <p>通过这些例子我们注意到，根据新旧标签的子节点的类型不同，我们可以轻松地找到合适的方式去更新它们，我们在讲解 <code>VNode</code> 的种类时就曾经强调过，<code>VNode</code> 的类型标识在 <code>patch</code> 阶段是非常重要的信息，在这里就体现了出来。</p> <p>但无论是新标签还是旧标签，该标签的子节点都可以分为三种情况：只有一个子节点、没有子节点 以及 有多个子节点。至于一个标签的子节点属于哪种类型是可以通过该标签所对应的 <code>VNode</code> 对象的 <code>childFlags</code> 属性得知的。最终在这个思路的引导下我们就可以编写出 <code>patchChildren</code> 函数，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 旧的 children 是单个子节点，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 也是单个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
    <span class="token comment">// 旧的 children 中没有子节点时，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 是单个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
    <span class="token comment">// 旧的 children 中有多个子节点时，会执行该 case 语句块</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 是单个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><p>如上代码所示，虽然看上去代码很长，但是很有规律，我们使用了嵌套的 <code>switch...case</code> 语句，外层的 <code>switch...case</code> 语句用来匹配旧的 <code>children</code> 的类型，而内层的 <code>switch...case</code> 语句则用来匹配新的 <code>children</code> 的类型。由于新旧 <code>children</code> 各有三种情况，所以合起来共有九种(<code>3 * 3</code>)情况，根据不同的情况我们所做的操作也会不同。接下来我们逐个实现，当我们把这九种情况下的更新操作全部实现之后，我们的 <code>patchChildren</code> 函数就大功告成了。</p> <p>我们先来看一下当旧的 <code>children</code> 类型为 <code>ChildrenFlags.SINGLE_VNODE</code> 且新的 <code>children</code> 类型也是 <code>ChildrenFlags.SINGLE_VNODE</code> 的情况，即新旧 <code>children</code> 都是单个子节点，我们上面提到过，在这种情况下新旧 <code>children</code> 的比较等价于两个 <code>children(单个子节点)</code>之间的比较，所以只需要递归地调用 <code>patch</code> 函数即可，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 此时 prevChildren 和 nextChildren 都是 VNode 对象</span>
          <span class="token function">patch</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>

    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>如上高亮代码所示，只需一行代码即可搞定，我们编写一个案例来测试我们的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    style<span class="token operator">:</span> <span class="token punctuation">{</span>
      height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      background<span class="token operator">:</span> <span class="token string">'red'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    style<span class="token operator">:</span> <span class="token punctuation">{</span>
      height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      background<span class="token operator">:</span> <span class="token string">'green'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>如上代码所示，新旧 <code>VNode</code> 描述的都是只有一个 <code>p</code> 标签作为子节点的 <code>div</code> 标签，所以新旧 <code>div</code> 标签的 <code>children</code> 类型都是单个子节点，只不过这两个 <code>p</code> 标签拥有不同的背景颜色，然后我们先后调用 <code>render</code> 渲染器渲染了这两个 <code>VNode</code>，最终效果是 <code>p</code> 标签的背景色被正确地更新了。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/m3oqr3knq9</p> <p><a href="https://codesandbox.io/s/m3oqr3knq9" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>接着我们来看一下当旧的 <code>children</code> 类型为 <code>ChildrenFlags.SINGLE_VNODE</code>，而新的 <code>children</code> 类型为 <code>ChildrenFlags.NO_CHILDREN</code> 时的情况，也就是说旧的 <code>children</code> 是单个子节点，而新的 <code>children</code> 为 <code>null</code>，即新的 <code>VNode</code> 没有子节点。在这种情况下我们只需要把旧的子节点移除即可，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 旧的 children 是单个子节点，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 也是单个子节点时，会执行该 case 语句块</span>
          <span class="token function">patch</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>

    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>如上高亮代码所示，<code>container</code> 是父级元素，我们调用父级元素的 <code>removeChild</code> 方法将之前渲染好的 <code>prevChildren.el</code> 移除即可，同样只使用了一行代码就实现了功能。不过可能很多同学已经发现了这么做的问题所在，假如 <code>prevChildren</code> 的类型是一个片段的话，那么它可能渲染多个元素到容器中，所以我们需要对片段类型的 <code>VNode</code> 额外处理。但本质不变：<strong>想办法把已经渲染好了的 DOM 元素从页面上移除</strong>。</p> <p>最后我们使用如下例子测试我们的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
  <span class="token string">'div'</span><span class="token punctuation">,</span>
  <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    style<span class="token operator">:</span> <span class="token punctuation">{</span>
      height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      background<span class="token operator">:</span> <span class="token string">'red'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>上例中 <code>prevVNode</code> 描述的是：以一个红色背景的 <code>p</code> 标签作为子节点的 <code>div</code> 标签，而 <code>nextVNode</code> 是一个没有子节点的 <code>div</code> 标签，接着我们先后渲染了旧的和新的 <code>VNode</code>，最终效果是 <code>p</code> 标签被移除了。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/3roo60w1kp</p> <p><a href="https://codesandbox.io/s/3roo60w1kp" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>接着我们再来看一下当旧的 <code>children</code> 类型为 <code>ChildrenFlags.SINGLE_VNODE</code>，而新的 <code>children</code> 类型为多个子节点时的情况，在这种情况下由于旧的子节点只有一个，而新的子节点有多个，所以我们可以采用<strong>将旧的单个子节点移除，再将新的多个子节点挂载上去</strong>的方案，在这个思路下我们可以做出如下实现，修改我们的 <code>patchChildren</code> 函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 旧的 children 是单个子节点，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token function">patch</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 移除旧的单个子节点</span>
          container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token comment">// 遍历新的多个子节点，逐个挂载到容器中</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>

    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>如上高亮代码所示，实现起来也非常简单，我们使用了与之前一样的方法将旧的单个子节点移除，然后遍历新的多个子节点，并调用 <code>mount</code> 函数逐个将之挂载到容器中。我们可以使用下面的例子测试我们的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'只有一个子节点'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'子节点 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'子节点 2'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>如上代码所示，旧的 <code>VNode</code> 是一个只有一个子节点的 <code>div</code> 标签，而新的 <code>VNode</code> 是一个拥有多个子节点的 <code>div</code> 标签。最终的效果是旧的单个子节点被移除，新的多个子节点全都被添加上去。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/lpm17161m</p> <p><a href="https://codesandbox.io/s/lpm17161m" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>以上我们讲解并实现了当旧的 <code>children</code> 类型为单个子节点时，所有情况下的更新操作，可以用一张图来总结，如下：</p> <p><img src="http://hcysun.me/vue-design/assets/img/patch-children-1.39272592.png" alt="img"></p> <p>类似的，当旧的 <code>children</code> 类型为 <code>ChildrenFlags.NO_CHILDREN</code>，即没有子节点时，新的 <code>children</code> 依然可能有三种情况，我们也可以用一张图来表示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/patch-children-2.31ddc8a6.png" alt="img"></p> <p>我们来解释一下上图的操作：</p> <ul><li>情况一：没有旧的子节点、新的子节点为单个子节点，此时只需要把新的单个子节点添加到容器元素即可。</li> <li>情况二：没有旧的子节点、同时也没有新的子节点，那自然什么都不用做了。</li> <li>情况三：没有旧的子节点、但有多个新的子节点，那把这多个子节点都添加到容器元素即可。</li></ul> <p>基于此，我们可以轻松编写出对应的逻辑，如下 <code>patchChildren</code> 函数所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 旧的 children 中没有子节点时，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 是单个子节点时，会执行该 case 语句块</span>
          <span class="token comment">// 使用 mount 函数将新的子节点挂载到容器元素</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token comment">// 什么都不做</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token comment">// 遍历多个新的子节点，逐个使用 mount 函数挂载到容器元素</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>

    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/62x41myyrz</p> <p><a href="https://codesandbox.io/s/62x41myyrz" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>现在对于旧的 <code>children</code> 类型来说，我们只剩下最后一种情况没有处理了，就是当旧的 <code>children</code> 类型为多个子节点时，同样的我们来画一张图：</p> <p><img src="http://hcysun.me/vue-design/assets/img/patch-children-3.06453ea2.png" alt="img"></p> <p>如上图所示，当旧的 <code>children</code> 类型为多个子节点时，新的 <code>children</code> 类型有三种情况，不同的情况采用不同的操作：</p> <ul><li>情况一：有多个旧的子节点，但新的子节点是单个子节点，这时只需要把所有旧的子节点移除，再将新的单个子节点添加到容器元素即可。</li> <li>情况二：有多个旧的子节点，但没有新的子节点，这时只需要把所有旧的子节点移除即可。</li> <li>情况三：新旧子节点都是多个子节点，这时将进入到至关重要的一步，即核心 <code>diff</code> 算法的用武之地。</li></ul> <p>实际上在整个新旧 <code>children</code> 的比对中，只有当新旧子节点都是多个子节点时才有必要进行真正的核心 <code>diff</code>，从而尽可能的复用子节点。</p> <p>对于<strong>情况一</strong>和<strong>情况二</strong>而言，实现起来相当容易，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>如上高亮代码所示，对于新的 <code>children</code> 为单个子节点的情况，我们遍历旧的子节点逐个将之从容器元素中移除，并调用 <code>mount</code> 函数将新的子节点挂载到容器元素中，对于新的 <code>children</code> 为没有子节点的情况，我们则直接遍历旧的子节点将其全部从容器元素中移除即可。实际上整个 <code>children</code> 的 <code>patch</code> 过程中，最复杂的当属最后一种情况：<strong>新旧子节点都是多个子节点的情况</strong>，之所以在这种情况下更新操作会变的复杂，是因为我们对“自己”的要求较高，因为假设按照之前的思路我们完全可以采用 <strong>“将旧的子节点全部移除，再将所有新的子节点添加”</strong> 的思路来完成更新，这样事情就会简单许多，不过虽然这么做可以实现最终的目的，但所有 DOM 的更新都毫无复用可言。限于本章的篇幅我们暂时采用简单的办法完成子节点的更新，对于真正的核心 <code>diff</code> 算法我们将会在下一章统一着重讲解，简化版本的实现如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 旧的 children 中有多个子节点时，会执行该 case 语句块</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 遍历旧的子节点，将其全部移除</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 遍历新的子节点，将其全部添加</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>如上高亮代码所示，我们先遍历旧的子节点，将其全部从容器元素中移除。然后再遍历新的子节点，并将其全部添加到容器元素中。这样我们就完成了更新的操作，但这里再次强调：我们这么做是限于篇幅，同时为了方便后续案例代码的编写，在下一章中我们将着重讲解<strong>当新旧子节点都是多个子节点时，应该如何尽可能的复用子节点</strong>。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/ym6k442lmj</p> <p><a href="https://codesandbox.io/s/ym6k442lmj" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="更新文本节点"><a href="#更新文本节点" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9B%B4%E6%96%B0%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 更新文本节点</h2> <p>我们花了很大的篇幅讲解了标签元素的更新，实际上标签元素的确是 DOM 更新中的主要操作，接下来我们讲解一下文本节点的更新。如果新旧两个 <code>VNode</code> 的类型都是纯文本类型，那么在 <code>patch</code> 内部会调用 <code>patchText</code> 函数更新旧的文本节点。文本节点的更新非常简单，如果一个 DOM 元素是文本节点或注释节点，那么可以通过调用该 DOM 对象的 <code>nodeValue</code> 属性读取或设置文本节点(或注释节点)的内容，例如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 创建一个文本节点</span>
<span class="token keyword">const</span> textEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>

textEl<span class="token punctuation">.</span>nodeValue  <span class="token comment">// 'a'</span>

textEl<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> <span class="token string">'b'</span>

textEl<span class="token punctuation">.</span>nodeValue  <span class="token comment">// 'b'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>利用这一点我们就可以轻松实现对于文本元素的更新，如下是 <code>patchText</code> 函数的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchText</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拿到文本元素 el，同时让 nextVNode.el 指向该文本元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 只有当新旧文本内容不一致时才有必要更新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    el<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>children
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>patchText</code> 函数接收新旧 <code>VNode</code> 作为参数，首先我们需要通过旧的 <code>prevVNode.el</code> 属性拿到已经渲染在页面上的文本节点元素，并让 <code>nextVNode.el</code> 指向它。接着由于对纯文本类型的 <code>VNode</code> 而言，它的 <code>children</code> 属性存储的就是其文本内容，所以通过对比新旧文本内容是否一致来决定是否需要更新，只有新旧文本内容不一致时我们才会设置文本节点的 <code>el.nodeValue</code> 属性的值，从而完成文本节点的更新。</p> <p>我们可以使用如下例子测试我们的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧文本'</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新文本'</span><span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>我们先后创建了两个带有文本子节点的 <code>p</code> 标签，并调用 <code>render</code> 渲染器渲染了旧的 <code>VNode</code> 以及新的 <code>VNode</code>。最终效果是两秒之后文本被更新了。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/73zzzv9xn6</p> <p><a href="https://codesandbox.io/s/73zzzv9xn6" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="更新-fragment"><a href="#更新-fragment" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9B%B4%E6%96%B0-fragment" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 更新 Fragment</h2> <p>如果两个 <code>VNode</code> 的类型都是片段，则 <code>patch</code> 函数会调用 <code>patchFragment</code> 函数更新片段的内容。实际上<strong>片段的更新是简化版的标签元素的更新</strong>，我们知道对于标签元素来说更新的过程分为两个步骤：首先需要更新标签本身的 <code>VNodeData</code>，其次更新其子节点。然而由于 <code>Fragment</code> 没有包裹元素，只有子节点，所以我们对 <code>Fragment</code> 的更新本质上就是更新两个片段的“子节点”。</p> <p>如下是 <code>patchFragment</code> 函数的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchFragment</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 直接调用 patchChildren 函数更新 新旧片段的子节点即可</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 旧片段的子节点类型</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 新片段的子节点类型</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 旧片段的子节点</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 新片段的子节点</span>
    container
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如上代码所示，我们直接调用 <code>patchChildren</code> 函数更新新旧片段的子节点即可，但是不要忘记更新 <code>nextVNode.el</code> 属性，就像我们当初实现 <code>mountFragment</code> 时一样，根据子节点的类型不同，<code>VNode</code> 所引用的元素也不同，我们为 <code>patchFragment</code> 添加如下代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchFragment</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 直接调用 patchChildren 函数更新 新旧片段的子节点即可</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 旧片段的子节点类型</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 新片段的子节点类型</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 旧片段的子节点</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 新片段的子节点</span>
    container
  <span class="token punctuation">)</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>el
      <span class="token keyword">break</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
      nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el
      <span class="token keyword">break</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>如上高亮代码所示，我们通过检查新的片段的 <code>children</code> 类型，如果新的片段的 <code>children</code> 类型是单个子节点，则意味着其 <code>vnode.children</code> 属性的值就是 <code>VNode</code> 对象，所以直接将 <code>nextVNode.children.el</code> 赋值给 <code>nextVNode.el</code> 即可。如果新的片段没有子节点，我们知道对于没有子节点的片段我们会使用一个空的文本节点占位，而 <code>prevVNode.el</code> 属性引用的就是该空文本节点，所以我们直接通过旧片段的 <code>prevVNode.el</code> 拿到该空文本元素并赋值给新片段的 <code>nextVNode.el</code> 即可。如果新的片段的类型是多个子节点，则 <code>nextVNode.children</code> 是一个 <code>VNode</code> 数组，我们会让新片段的 <code>nextVNode.el</code> 属性引用数组中的第一个元素。实际上这段逻辑与我们在 <code>mountFragment</code> 函数中所实现的逻辑是一致的。</p> <p>我们可以使用下面的例子测试我们的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧片段子节点 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧片段子节点 2'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新片段子节点 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新片段子节点 2'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>如上这段代码中我们创建了旧的和新的两个片段，并先后使用渲染器进行渲染，结果是片段得到了正确的更新。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/1r9k5y1ozq</p> <p><a href="https://codesandbox.io/s/1r9k5y1ozq" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="更新-portal"><a href="#更新-portal" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9B%B4%E6%96%B0-portal" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 更新 Portal</h2> <p>如果两个 <code>VNode</code> 的类型都是 <code>Portal</code>，那么 <code>patch</code> 函数内部会调用 <code>patchPortal</code> 函数进行更新。我们在“渲染器之挂载”一章中曾做出一个不严谨但很直观的比喻：可以把 <code>Portal</code> 当作可以到处挂载的 <code>Fragment</code>。实际上 <code>Portal</code> 的更新与 <code>Fragment</code> 类似，我们需要更新其子节点，但由于 <code>Portal</code> 可以被到处挂载，所以新旧 <code>Portal</code> 的挂载目标可能不同，所以对于 <code>Portal</code> 的更新除了要更新其子节点之外，还要对比新旧挂载目标是否相同，如果新的 <code>Portal</code> 的挂载目标变了我们就需要将 <code>Portal</code> 的内容从旧的容器中搬运到新的容器中。我们首先来更新 <code>Portal</code> 的子节点，如下代码所示，与更新 <code>Fragment</code> 的子节点相同：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">patchPortal</span> <span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    prevVNode<span class="token punctuation">.</span>tag <span class="token comment">// 注意容器元素是旧的 container</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 让 nextVNode.el 指向 prevVNode.el</span>
  nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如上代码所示，我们首先调用 <code>patchChildren</code> 函数更新 <code>Portal</code> 的子节点，其中需要注意的是 <code>patchChildren</code> 的第五个参数是旧的挂载容器，也就是说即使新的 <code>Portal</code> 的挂载目标变了，但是在这一步的更新完成之后 <code>Portal</code> 的内容仍然存在于旧的容器中。接着我们将 <code>prevVNode.el</code> 赋值给 <code>nextVNode.el</code>，这一步要比 <code>Fragment</code> 容易的多，因为我们知道对于 <code>Portal</code> 类型的 <code>VNode</code> 来说其 <code>el</code> 属性始终是一个占位的文本节点。</p> <p>在如上这些工作完成之后，我们要思考的问题就是挂载目标了，由于新旧 <code>Portal</code> 的挂载目标可能是不同的，例如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 挂载目标是 id=&quot;box1&quot; 的元素</span>
<span class="token keyword">const</span> prevPortal <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Portal<span class="token punctuation">,</span> <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#box1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 挂载目标是 id=&quot;box2&quot; 的元素</span>
<span class="token keyword">const</span> nextPortal <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Portal<span class="token punctuation">,</span> <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#box2'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看到，旧的 <code>Portal</code> 的挂载目标是 <code>id=&quot;box1&quot;</code> 的容器元素，而新的 <code>Portal</code> 的挂载目标是 <code>id=&quot;box2&quot;</code> 的容器元素。但是由于我们在更新子节点的过程中，传递给 <code>patchChildren</code> 函数的容器元素始终都是旧的容器元素，所以最终结果是：<strong>更新后的子节点也存在于旧的容器中</strong>，所以我们还需要做最后一步工作，就是<strong>把旧容器内的元素都搬运到新容器中</strong>，我们给 <code>patchPortal</code> 函数增加如下代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchPortal</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    prevVNode<span class="token punctuation">.</span>tag <span class="token comment">// 注意 container 是旧的 container</span>
  <span class="token punctuation">)</span>
  <span class="token comment">// 让 nextVNode.el 指向 prevVNode.el</span>
  nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el

  <span class="token comment">// 如果新旧容器不同，才需要搬运</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取新的容器元素，即挂载目标</span>
    <span class="token keyword">const</span> container <span class="token operator">=</span>
      <span class="token keyword">typeof</span> nextVNode<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'string'</span>
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> nextVNode<span class="token punctuation">.</span>tag

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
        <span class="token comment">// 如果新的 Portal 是单个子节点，就把该节点搬运到新容器中</span>
        container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
        <span class="token comment">// 新的 Portal 没有子节点，不需要搬运</span>
        <span class="token keyword">break</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token comment">// 如果新的 Portal 是多个子节点，遍历逐个将它们搬运到新容器中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>如上高亮代码所示，我们通过 <code>nextVNode.tag !== prevVNode.tag</code> 来判断新旧 <code>Portal</code> 的容器是否相同，只有容器不同的情况下才需要搬运工作。搬运的原理是什么呢？我们知道当我们调用 <code>appendChild</code> 方法向 DOM 中添加元素时，如果被添加的元素已存在于页面上，那么就会移动该元素到目标容器元素下。我们利用这一点，由于经过 <code>patchChildren</code> 函数的处理之后，新的子节点已经存在于旧的容器中了，所以我们只需要在新容器元素上调用 <code>appendChild</code> 方法将这些已经存在于旧容器中的子节点搬运过去即可。</p> <p>当然了，在搬运的过程中，我们要检查新的 <code>Portal</code> 的子节点类型，并采用合适的处理方式。我们可以使用如下例子测试我们的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
  Portal<span class="token punctuation">,</span>
  <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#old-container'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧的 Portal'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
  Portal<span class="token punctuation">,</span>
  <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#new-container'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新的 Portal'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>如上代码所示，在这个例子中 <code>prevVNode</code> 和 <code>nextVNode</code> 的类型都是 <code>Portal</code>，并且新旧 <code>Portal</code> 的挂载目标不同，分别是 <code>#old-container</code> 和 <code>#new-container</code>，如下是完整的代码和在线体验地址。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/xj118zm82o</p> <p><a href="https://codesandbox.io/s/xj118zm82o" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="有状态组件的更新"><a href="#有状态组件的更新" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 有状态组件的更新</h2> <p>接下来我们要介绍的就是有状态组件的更新，首先我们需要思考的问题是：在什么情况下才会触发有状态组件的更新呢？实际上对于有状态组件来说它的更新方式有两种：<strong>主动更新</strong> 和 <strong>被动更新</strong>。</p> <p>什么是<strong>主动更新</strong>呢？所谓主动更新指的是组件自身的状态发生变化所导致的更新，例如组件的 <code>data</code> 数据发生了变化就必然需要重渲染。但是大家不要忘记：一个组件所渲染的内容是很可能包含其它组件的，也就是子组件，对于子组件来讲，它除了自身状态之外，很可能还包含从父组件传递进来的外部状态(<code>props</code>)，所以父组件自身状态的变化很可能引起子组件外部状态的变化，此时就需要更新子组件，像这种因为外部状态变化而导致的组件更新就叫做<strong>被动更新</strong>。</p> <h3 id="主动更新"><a href="#主动更新" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 主动更新</h3> <p>我们先来讨论组件的主动更新，我们知道组件的核心是渲染函数，渲染函数会产出 <code>VNode</code>，渲染器会将渲染函数产出的 <code>VNode</code> 渲染为真实 DOM，当组件的状态变化时我们需要做的就是重新执行渲染函数并产出新的 <code>VNode</code>，最后通过新旧 <code>VNode</code> 之间的补丁算法完成真实 DOM 的更新。这里的关键点在于<strong>数据变化之后需要重新执行渲染函数，得到新的 VNode</strong>，我们来回顾一下前面章节中讲解过的用于挂载有状态组件的 <code>mountStatefulComponent</code> 函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 渲染VNode</span>
  instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 挂载</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
  <span class="token comment">// el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
  instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>组件挂载的核心步骤分为三步：1、创建组件实例，2、调用组件的 <code>render</code> 获得 <code>VNode</code>，3、将 <code>VNode</code> 挂载到容器元素。实际上我们可以把除了创建组件实例这一步之外的代码封装成一个函数，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  instance<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、渲染VNode</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 2、挂载</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
    <span class="token comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
    instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
  <span class="token punctuation">}</span>

  instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>如上代码所示，在 <code>mountStatefulComponent</code> 函数内部，我们将除了创建组件实例之外的所有工作封装到了组件实例对象的 <code>instance._update</code> 函数中，紧接着在 <code>mountStatefulComponent</code> 函数的最后立即调用了 <code>_update</code> 函数，我们为什么要这么做呢？实际上 <code>_update</code> 函数所做的工作就是渲染组件，这样当组件自身状态发生变化后，我们就可以再次调用 <code>_update</code> 函数来完成组件的更新。</p> <p>假设我们有 <code>MyComponent</code> 组件，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// 自身状态 or 本地状态</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token comment">// mounted 钩子</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 两秒钟之后修改本地状态的值，并重新调用 _update() 函数更新组件</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>localState <span class="token operator">=</span> <span class="token string">'two'</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>如上组件所示，该组件拥有一个叫做 <code>localState</code> 的数据，并且 <code>render</code> 函数中使用到了该数据。接着我们在组件的 <code>mounted</code> 钩子函数中设置了一个定时器，两秒钟之后会修改自身状态 <code>localState</code> 的值，由于我们目前没有讲解响应系统，所以我们暂时需要手动调用 <code>_update</code> 函数来完成组件的更新，等到后面响应系统相关的章节中我们再来详细讲解如何完成自动更新。另外在如上组件中我们使用了 <code>mounted</code> 生命周期钩子，但是就我们目前所实现的 <code>mountStatefulComponent</code> 函数而言，它并没有调用组件的任何生命周期函数的能力，为了代码的正常运行，我们需要为 <code>mountStatefulComponent</code> 函数添加执行 <code>mounted</code> 回调的能力，很简单我们只需要在组件被渲染为真实 DOM 之后调用该组件实例的 <code>mounted</code> 函数即可，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  instance<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、渲染VNode</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 2、挂载</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
    <span class="token comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
    instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
    <span class="token comment">// 5、调用 mounted 钩子</span>
    instance<span class="token punctuation">.</span>mounted <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>这样当我们使用 <code>mountStatefulComponent</code> 函数挂载有状态组件时，如果组件提供了 <code>mounted</code> 方法，那么该方法就会被当作钩子函数调用，更多的关于生命周期钩子函数的内容我们暂且不做深入讨论，我们还是回到组件更新的问题上。现在 <code>MyComponent</code> 组件的 <code>mounted</code> 钩子函数已经可以被正确执行，我们在 <code>mounted</code> 钩子函数内修改了组件的自身状态的值并再次调用了 <code>_update</code> 函数进行组件的更新，但是在更新时我们不应该像初次挂载组件那样去调用 <code>mount</code> 函数，而是应该调用 <code>patch</code> 函数将组件新产出的 <code>VNode</code> 与初次挂载时产出的旧 <code>VNode</code> 做比较并完成更新，但无论是初次挂载还是后续更新我们调用的都是 <code>_update</code> 函数，可是 <code>_update</code> 函数怎么知道当前这次渲染到底是初次挂载还是后续更新呢？所以我们需要为组件实例设计一个 <code>boolean</code> 类型的状态标识，用来标记组件是否已经被挂载，这样 <code>_update</code> 函数就能够区分当前这次渲染到底是初次挂载还是后续更新了，如下是我们修改之后的 <code>mountStatefulComponent</code> 函数的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  instance<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 instance._mounted 为真，说明组件已挂载，应该执行更新操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">.</span>_mounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1、拿到旧的 VNode</span>
      <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode
      <span class="token comment">// 2、重渲染新的 VNode</span>
      <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 3、patch 更新</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>parentNode<span class="token punctuation">)</span>
      <span class="token comment">// 4、更新 vnode.el 和 $el</span>
      instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1、渲染VNode</span>
      instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 2、挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// 3、组件已挂载的标识</span>
      instance<span class="token punctuation">.</span>_mounted <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
      instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
      <span class="token comment">// 5、调用 mounted 钩子</span>
      instance<span class="token punctuation">.</span>mounted <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>如上代码所示，我们通过一个 <code>if...else</code> 语句判断组件实例的 <code>instance._mounted</code> 属性值的真假，来判断应该执行初次挂载操作还是更新操作。<code>if</code> 语句块内的代码用于执行更新操作，大致分为四个步骤：</p> <ul><li>1、取得旧的 <code>VNode</code>，由于初次挂载组件时所产出的 <code>VNode</code> 存储在组件实例的 <code>$vnode</code> 属性中，所以我们可以通过 <code>$vnode</code> 属性拿到旧的 <code>VNode</code>。</li> <li>2、重新调用 <code>render</code> 函数产出新的 <code>VNode</code>。</li> <li>3、调用 <code>patch</code> 函数对比新旧 <code>VNode</code>，完成更新操作。</li></ul> <p>除了以上三步之外，我们还应该使用新的真实 DOM 元素去更新 <code>vnode.el</code> 属性和组件实例的 <code>$el</code> 属性的值。另外大家注意我们在第三步中传递给 <code>patch</code> 函数的第三个参数，它是容器元素，这个容器元素可以通过获取旧的 <code>vnode.el</code> 的父节点得到。</p> <p>现在组件的主动更新我们就讲解完了，下面的链接是完整代码和线上体验地址。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/jzl0nk81xy</p> <p><a href="https://codesandbox.io/s/jzl0nk81xy" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="初步了解组件的外部状态-props"><a href="#初步了解组件的外部状态-props" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81-props" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 初步了解组件的外部状态 props</h3> <p>上面我们讲解了有状态组件的主动更新，接下来我们本应该继续讲解有状态组件的被动更新，但是在讲解被动更新之前，需要花点时间来做一些铺垫，我们先了解一下组件的 <code>props</code>，为什么需要了解 <code>props</code> 呢？因为组件的被动更新是由组件的外部状态变化所导致的，而 <code>props</code> 就是组件的外部状态。不过本节不会深入讨论 <code>props</code>，点到为止，我们会在后续的章节中专门详细地讲解 <code>props</code>。</p> <p>假设父组件的模板如下：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 父组件模板 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span> <span class="token attr-name">:text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>localState<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>父组件的模板中渲染了 <code>ChildComponent</code> 子组件，<code>ChildComponent</code> 子组件有一个 <code>text</code> 属性，它是一个绑定属性，绑定的变量是父组件的自身状态 <code>localState</code>。这段模板被编译后的渲染函数可以表示为：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这段渲染函数就是父组件的渲染函数，所以我们可以这样定义父组件：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// 本地状态</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    childCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> childCompVNode
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如上代码所示，父组件渲染函数所返回的就是子组件的 <code>VNode</code>，即 <code>childCompVNode</code>。<code>childCompVNode</code> 将会被 <code>mountStatefulComponent</code> 函数挂载，挂载的步骤我们已经再熟悉不过了：1、创建组件实例，2、调用组件实例的 <code>render</code> 函数，3、调用 <code>mount</code> 函数挂载。实际上我们可以在组件实例创建之后立即初始化组件的 <code>props</code>。为 <code>mountStatefulComponent</code> 函数添加如下代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// 初始化 props</span>
  instance<span class="token punctuation">.</span>$props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data

  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如上高亮代码所示，在组件实例创建完成之后，我们为组件实例添加了 <code>$props</code> 属性，并且将 <code>vnode.data</code> 赋值给 <code>$props</code>。这样，子组件中就可以通过 <code>this.$props.text</code> 访问从父组件传递进来的 <code>props</code> 数据。如下是 <code>ChildComponent</code> 组件中使用外部数据的方式：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 子组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ChildComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过 this.$props.text 访问外部数据</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$props<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这样我们就实现了父组件向子组件传递 <code>props</code> 的能力，不过在该实现中我们以最简单的方式，直接将 <code>VNodeData</code> 赋值给 <code>$props</code>，我们知道 <code>VNodeData</code> 中的数据并不全是 <code>props</code>，其中还包含事件以及其他重要的信息，所以在真正的实现中，我们会从 <code>VNodeData</code> 中提取 <code>props</code>。不过这并不是本章的重点内容，我们一切从简。</p> <p>现在子组件已经有能力拿到从父组件传递进来的 <code>props</code> 数据了，我们可以使用如下例子测试我们的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 子组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ChildComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 子组件中访问外部状态：this.$props.text</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$props<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 父组件向子组件传递的 props</span>
      text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 有状态组件 VNode</span>
<span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ParentComponent<span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>这里是完整的代码和在线体验地址：https://codesandbox.io/s/k5lll524m5</p> <p><a href="https://codesandbox.io/s/k5lll524m5" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>，可以看到如上代码能够正确运行，子组件中可以访问由父组件传递进来的数据。</p> <h3 id="被动更新"><a href="#被动更新" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E8%A2%AB%E5%8A%A8%E6%9B%B4%E6%96%B0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 被动更新</h3> <p>有了 <code>props</code> 的铺垫之后，我们可以开始讨论有状态组件的<strong>被动更新</strong>了。如前所述，被动更新指的是由外部状态变化而引起的更新操作，通常父组件自身状态的变化可能会引起子组件的更新，我们可以修改上面的例子，为父组件添加 <code>mounted</code> 钩子，并在该钩子函数中修改父组件的自身状态 <code>localState</code> 的值，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 子组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ChildComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 子组件中访问外部状态：this.$props.text</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$props<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 两秒钟后将 localState 的值修改为 'two'</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>localState <span class="token operator">=</span> <span class="token string">'two'</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 父组件向子组件传递的 props</span>
      text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 有状态组件 VNode</span>
<span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ParentComponent<span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>如上高亮代码所示，我们为父组件定义了 <code>mounted</code> 钩子函数，在 <code>mounted</code> 钩子函数内我们设置了一个定时器，两秒钟后修改 <code>localState</code> 的值为 <code>'two'</code> 并调用 <code>_update</code> 方法更新父组件。这个过程我们可以理解为父组件 <code>ParentComponent</code> 先后产出了两个不同的 <code>VNode</code>：第一次渲染产出的 <code>VNode</code> 是：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> prevCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'one'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>第二次由于自身状态变化所产出的 <code>VNode</code> 为：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> nextCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'two'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>所以在 <code>_update</code> 函数内部的更新操作，等价于 <code>prevCompVNode</code> 和 <code>nextCompVNode</code> 之间的 <code>patch</code>，即：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">patch</span><span class="token punctuation">(</span>prevCompVNode<span class="token punctuation">,</span> nextCompVNode<span class="token punctuation">,</span> prevCompVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>parentNode<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>由于 <code>prevCompVNode</code> 和 <code>nextCompVNode</code> 的类型都是组件类型的 <code>VNode</code>，所以在 <code>patch</code> 函数内部会调用 <code>patchComponent</code> 函数进行更新，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextFlags <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>flags
  <span class="token keyword">const</span> prevFlags <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>flags

  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevFlags <span class="token operator">!==</span> nextFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchElement</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchComponent</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchText</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchFragment</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchPortal</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><code>patchComponent</code> 函数接收三个参数，分别是旧的 <code>VNode</code> 和新的 <code>VNode</code> 以及容器元素 <code>container</code>，如下是 <code>patchComponent</code> 函数的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 检查组件是否是有状态组件</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、获取组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
    <span class="token comment">// 2、更新 props</span>
    instance<span class="token punctuation">.</span>$props <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
    <span class="token comment">// 3、更新组件</span>
    instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如上代码所示，我们通过检查组件的 <code>flags</code> 判断组件是否是有状态组件，如果是有状态组件则更新之。更新操作很简单，三步：</p> <ul><li>1、通过 <code>prevVNode.children</code> 拿到组件实例</li> <li>2、更新 <code>props</code>，使用新的 <code>VNodeData</code> 重新设置组件实例的 <code>$props</code> 属性</li> <li>3、由于组件的 <code>$props</code> 已更新，所以调用组件的 <code>_update</code> 方法，让组件重渲染。</li></ul> <p>这里需要澄清的一件事，我们之所以能够通过 <code>VNode</code> 的 <code>children</code> 属性来读取组件实例，例如上面代码中的 <code>prevVNode.children</code>，是因为每个类型为有状态组件的 <code>VNode</code>，在挂载期间我们都会让其 <code>children</code> 属性引用组件的实例，以便能够通过 <code>VNode</code> 访问组件实例对象。这一点我们早在“先设计 VNode 吧”一章中就有提及。所以我们需要修改 <code>mountStatefulComponent</code> 函数的代码，在创建组件实例后需要将实例对象赋值给 <code>vnode.children</code> 属性，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这样我们在 <code>patchComponent</code> 函数中就能够通过 <code>VNode</code> 拿到组件实例了，这里我们再次强调：<code>VNode</code> 的 <code>children</code> 属性本应该用来存储子节点，但是对于组件类型的 <code>VNode</code> 来说，它的子节点都应该作为插槽存在，并且我们选择将插槽内容存储在单独的 <code>slots</code> 属性中，而非存储在 <code>children</code> 属性中，这样 <code>children</code> 属性就可以用来存储组件实例了，这些内容我们会在后面章节中讲解插槽时再次说明。</p> <p>如下是完整代码以及在线体验地址：</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/2z7335kn5y</p> <p><a href="https://codesandbox.io/s/2z7335kn5y" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>在上面的讲解中，父组件自身状态变化之后，它渲染的子组件并没有变化，仍然是 <code>ChildComponent</code>，仅仅是传递给子组件的 <code>props</code> 数据发生了变化。但是，有时父组件自身状态的变化会导致父组件渲染不同的子组件，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 父组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
  isTrue <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>isTrue <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 this.isTrue 的值为真，则渲染 ChildComponent1，否则渲染 ChildComponent2</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>isTrue <span class="token operator">?</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent1<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent2<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 有状态组件 VNode</span>
<span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ParentComponent<span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>如上代码所示，观察 <code>ParentComponent</code> 组件的 <code>render</code> 函数，当 <code>ParentComponent</code> 组件的自身状态 <code>isTrue</code> 为真时会渲染子组件 <code>ChildComponent1</code>，否则会渲染子组件 <code>ChildComponent2</code>。同时我们在 <code>mounted</code> 钩子中设置了定时器，两秒钟后将 <code>isTrue</code> 的值变更为 <code>false</code>，并调用 <code>_update</code> 方法更新 <code>ParentComponent</code> 组件。在这种情况下就会出现因父组件自身状态的变化而导致其渲染不同的组件，在初次挂载时 <code>ParentComponent</code> 组件所产出的 <code>VNode</code> 为：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> pervCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent1<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>更新之后 <code>ParentComponent</code> 组件所产出的 <code>VNode</code> 为：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> nextCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent2<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>虽然 <code>pervCompVNode</code> 和 <code>nextCompVNode</code> 的类型都是组件，但它们是不同的组件。拿上面的例子来说，<code>pervCompVNode</code> 描述的是组件 <code>ChildComponent1</code>，<code>nextCompVNode</code> 描述的是组件 <code>ChildComponent2</code>，也就是说新旧 <code>VNode</code> 所描述的不是同一个组件，这就引申出我们更新组件的一个原则：<strong>我们认为不同的组件渲染不同的内容</strong>，所以对于不同的组件，我们采用的方案是使用新组件的内容替换旧组件渲染的内容。根据这个思想，我们修改 <code>patchComponent</code> 函数的代码，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// tag 属性的值是组件类，通过比较新旧组件类是否相等来判断是否是相同的组件</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
    <span class="token comment">// 更新 props</span>
    instance<span class="token punctuation">.</span>$props <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
    <span class="token comment">// 更新组件</span>
    instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>如上 <code>patchComponent</code> 函数中的高亮代码所示，增加了一个判断条件，我们知道对于组件类型的 <code>VNode</code> 而言，它的 <code>tag</code> 属性值引用的就是组件类本身，我们通过对比前后组件类是否相同来确定新旧组件是否是相同的组件，如果不相同则直接调用 <code>replaceVNode</code> 函数使用新组件替换旧的组件。大家还记的 <code>replaceVNode</code> 函数的实现方式吗？如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这是我们之前实现过的 <code>replaceVNode</code> 函数，它的原理就是将旧的 <code>VNode</code> 所渲染的内容从容器元素中移除，并将新的 <code>VNode</code> 挂载到容器元素中。这段代码同样适用于组件，但是对于组件来说我们不能仅仅将组件所渲染的内容移除就算大功告成，我们还有另外一件事需要做，即调用 <code>unmounted</code> 钩子，所以我们为 <code>replaceVNode</code> 函数添加如下代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 如果将要被移除的 VNode 类型是组件，则需要调用该组件实例的 unmounted 钩子函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类型为有状态组件的 VNode，其 children 属性被用来存储组件实例对象</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children
    instance<span class="token punctuation">.</span>unmounted <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">unmounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如上高亮代码所示，如果将要被移除的 <code>prevVNode</code> 的类型是有状态组件，则需要调用该组件实例的 <code>unmounted</code> 钩子函数。这里是完整的代码以及在线体验地址：https://codesandbox.io/s/ll92yq0o2l</p> <p><a href="https://codesandbox.io/s/ll92yq0o2l" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>。</p> <h3 id="我们需要-shouldupdatecomponent"><a href="#我们需要-shouldupdatecomponent" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81-shouldupdatecomponent" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 我们需要 shouldUpdateComponent</h3> <p>【占位】</p> <h2 id="函数式组件的更新"><a href="#函数式组件的更新" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-patch.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 函数式组件的更新</h2> <p>接下来我们要讨论的是函数式组件的更新，其实无论是有状态组件还是函数式组件，它们的更新原理都是一样的：用组件新产出的 <code>VNode</code> 与之前产出的旧 <code>VNode</code> 进行比对，从而完成更新。为了让讲解不至于太抽象，我们还是拿一个具体的例子来说，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 子组件 - 函数式组件</span>
<span class="token keyword">function</span> <span class="token function">MyFunctionalComp</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父组件的 render 函数中渲染了 MyFunctionalComp 子组件</span>
<span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>localState <span class="token operator">=</span> <span class="token string">'two'</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>MyFunctionalComp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 有状态组件 VNode</span>
<span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ParentComponent<span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>观察上面的代码，我们定义了 <code>ParentComponent</code> 组件，它是一个有状态组件，在它的 <code>render</code> 函数中渲染了 <code>MyFunctionalComp</code> 子组件，这个子组件是一个函数式组件。观察 <code>MyFunctionalComp</code> 函数的参数，由于函数式组件没有组件实例，所以在函数式组件中我们不能通过 <code>this.$props.xxx</code> 访问 <code>props</code> 数据，<code>props</code> 数据是作为函数的参数传递进去的，如下是我们之前实现的 <code>mountFunctionalComponent</code> 函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 VNode</span>
  <span class="token keyword">const</span> $vnode <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 挂载</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
  <span class="token comment">// el 元素引用该组件的根元素</span>
  vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>为了实现函数式组件的 <code>props</code> 传递，我们需要修对 <code>mountFunctionalComponent</code> 函数做一些修改，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 props</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token comment">// 获取 VNode</span>
  <span class="token keyword">const</span> $vnode <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// 挂载</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
  <span class="token comment">// el 元素引用该组件的根元素</span>
  vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如上高亮代码所示，我们在调用组件函数获取 <code>VNode</code> 之前，要先获取 <code>props</code>，这里我们同样直接将整个 <code>VNodeData</code> 作为 <code>props</code> 数据，前面我们已经解释了这么做的原因是出于简便。拿到 <code>props</code> 数据之后，在调用组件函数 <code>vnode.tag(props)</code> 时将 <code>props</code> 作为参数传递过去，这样子组件就可以通过参数访问由父组件传递过来的数据了。另外，我们将组件产出的 <code>VNode</code> 赋值给了 <code>vnode.children</code> 属性，这里需要做一些说明，通过之前的讲解可知，对于有状态组件类型的 <code>VNode</code> 来说，我们使用其 <code>children</code> 属性存储组件实例，并在将来会用 <code>slots</code> 属性存储插槽数据。同样的，在函数式组件中，由于函数式组件没有组件实例，所以对于函数式组件类型的 <code>VNode</code>，我们用其 <code>children</code> 属性存储组件产出的 <code>VNode</code>，将来也会使用 <code>slots</code> 属性存储插槽数据。这个是设计上的决定，并非一定要这么做，但为了与 <code>Vue3</code> 的设计保持一致，所以我们就沿用 <code>Vue3</code> 的设计。</p> <p>现在我们已经实现了函数式组件接收 <code>props</code> 数据的功能，我们再来观察一下上面的例子，在这个例子中我们为有状态组件 <code>ParentComponent</code> 提供了 <code>mounted</code> 钩子函数，两秒之后修改自身状态 <code>localState</code> 的值，并调用 <code>_update</code> 函数重渲染，在重渲染的过程中，<code>_update</code> 函数内部发生的事情等价于：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyFunctionalComp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'one'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyFunctionalComp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'two'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 更新</span>
<span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>parentNode<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>由于 <code>prevVNode</code> 和 <code>nextVNode</code> 的类型都是组件，所以在 <code>patch</code> 函数内部会调用 <code>patchComponent</code> 函数更新，我们来回顾一下 <code>patchComponent</code> 函数的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
    <span class="token comment">// 更新 props</span>
    instance<span class="token punctuation">.</span>$props <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
    <span class="token comment">// 更新组件</span>
    instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在这段代码中 <code>if</code> 语句块内的代码用于处理两个不同组件之间的更新，<code>else...if</code> 语句块内的代码用于处理有状态组件的更新，所以<code>patchComponent</code> 函数还不能完成函数式组件的更新。为了达到目的，我们需要为 <code>patchComponent</code> 函数添加一段代码，用来处理函数式组件类型的 <code>VNode</code> 的更新，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在这里编写函数式组件的更新逻辑</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如上高亮代码所示，我们只需要为其添加 <code>else</code> 语句块即可，我们将在这里编写函数式组件的更新逻辑。但问题是，应该如何更新呢？在本节的开头我们就说过了，无论是有状态组件还是函数式组件，它们的更新原理不变，所以我们可以效仿有状态组件的实现方式。</p> <p>挂载函数式组件的核心步骤只有两步：1、调用组件的定义函数，拿到组件产出的 <code>VNode</code>，2、将 <code>VNode</code> 挂载到容器元素。与挂载有状态组件类似，我们可以把这些步骤封装到一个函数中，当组件更新时再次调用这个函数即可。但是，与有状态组件不同，函数式组件没有组件实例，所以我们没办法封装类似 <code>instance._update</code> 这样的函数，那应该怎么办呢？很简单，我们把 <code>update</code> 函数定义在函数式组件的 <code>VNode</code> 上就可以了，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在函数式组件类型的 vnode 上添加 handle 属性，它是一个对象</span>
  vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
    prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 初始化 props</span>
      <span class="token keyword">const</span> props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
      <span class="token comment">// 获取 VNode</span>
      <span class="token keyword">const</span> $vnode <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// el 元素引用该组件的根元素</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 立即调用 vnode.handle.update 完成初次挂载</span>
  vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这是我们修改后的 <code>mountFunctionalComponent</code> 函数，可以看到我们给函数式组件类型的 <code>VNode</code> 添加了 <code>handle</code> 属性，它是一个拥有四个属性的对象：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
  prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
  container<span class="token punctuation">,</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们把之前用于挂载函数式组件的代码移动到了 <code>vnode.handle.update</code> 函数中，所以在 <code>mountFunctionalComponent</code> 函数的最后立即调用了 <code>vnode.handle.update</code> 函数，这样能够保证原始功能不变。<code>handle</code> 对象除了 <code>update</code> 方法之外还有其他三个属性，它们的作用分别是：</p> <ul><li><code>handle.prev</code>：存储旧的函数式组件 <code>VNode</code>，在初次挂载时，没有旧的 <code>VNode</code> 可言，所以初始值为 <code>null</code>。</li> <li><code>handle.next</code>：存储新的函数式组件 <code>VNode</code>，在初次挂载时，被赋值为当前正在挂载的函数式组件 <code>VNode</code>。</li> <li><code>handle.container</code>：存储的是挂载容器</li></ul> <p>现在已经有了 <code>handle.update</code> 函数，我们可以尝试在 <code>patchComponent</code> 函数内部通过调用 <code>handle.update</code> 函数完成函数式组件的更新，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新函数式组件</span>
    <span class="token comment">// 通过 prevVNode.handle 拿到 handle 对象</span>
    <span class="token keyword">const</span> handle <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>handle <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>handle<span class="token punctuation">)</span>
    <span class="token comment">// 更新 handle 对象</span>
    handle<span class="token punctuation">.</span>prev <span class="token operator">=</span> prevVNode
    handle<span class="token punctuation">.</span>next <span class="token operator">=</span> nextVNode
    handle<span class="token punctuation">.</span>container <span class="token operator">=</span> container

    <span class="token comment">// 调用 update 函数完成更新</span>
    handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>如上高亮代码所示，我们首先通过旧的 <code>VNode(prevVNode)</code> 拿到 <code>handle</code> 对象，接着我们更新了 <code>handle</code> 对象下各个属性的值：</p> <ul><li>1、将旧的函数式组件 <code>VNode(prevVNode)</code> 赋值给 <code>handle.prev</code>。</li> <li>2、将新的函数式组件 <code>VNode(nextVNode)</code> 赋值给 <code>handle.next</code>。</li> <li>3、更新 <code>container</code>（即使 <code>container</code> 未必会变，但仍要更新之）。</li></ul> <p>最后我们调用了 <code>handle.update</code> 函数完成更新操作。我们再详细地了解一下在这个过程中发生了什么，在函数式组件初次挂载完成后 <code>handle</code> 对象的值为：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
  prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> prevVNode<span class="token punctuation">,</span>
  container<span class="token punctuation">,</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在经过 <code>patchComponent</code> 函数对 <code>handle</code> 对象进行更新之后，<code>handle</code> 对象的值将变为：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
  prev<span class="token operator">:</span> prevVNode<span class="token punctuation">,</span>
  next<span class="token operator">:</span> nextVNode<span class="token punctuation">,</span>
  container<span class="token punctuation">,</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可以看到此时的 <code>handle.prev</code> 属性已经非空了，<code>prev</code> 和 <code>next</code> 属性分别存储的是旧的和新的函数式组件类型的 <code>VNode</code>。这个更新的动作很关键。在更新完成之后，立即调用了 <code>handle.update</code> 函数进行重渲染，如下是目前我们所实现的 <code>handle.update</code> 函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在函数式组件类型的 vnode 上添加 handle 属性，它是一个对象</span>
  vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
    prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 初始化 props</span>
      <span class="token keyword">const</span> props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
      <span class="token comment">// 获取 VNode</span>
      <span class="token keyword">const</span> $vnode <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// el 元素引用该组件的根元素</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 立即调用 vnode.handle.update 完成初次挂载</span>
  vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>如上高亮代码所示，现在的 <code>update</code> 函数只能完成初次挂载的工作，当再次调用 <code>update</code> 函数进行更新时，我们是不能再次执行这段用于挂载的代码的，就像有状态组件的 <code>instance.update</code> 函数的实现一样，我们需要为 <code>handle.update</code> 函数添加更新逻辑，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
    prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新的逻辑写在这里</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取 props</span>
        <span class="token keyword">const</span> props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
        <span class="token comment">// 获取 VNode</span>
        <span class="token keyword">const</span> $vnode <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 挂载</span>
        <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
        <span class="token comment">// el 元素引用该组件的根元素</span>
        vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 立即调用 vnode.handle.update 完成初次挂载</span>
  vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>在上面的代码中，我们通过判断 <code>vnode.handle.prev</code> 是否存在来判断该函数式组件是初次挂载还是后续更新，由于在 <code>patchComponent</code> 函数内我们已经将 <code>vnode.handle.prev</code> 属性赋值为旧的组件 <code>VNode</code>，所以如果 <code>vnode.handle.prev</code> 存在则说明该函数式组件并非初次挂载，而是更新，所以我们会在 <code>if</code> 语句块内编写更新逻辑，而用于初次挂载的代码被我们放到了 <code>else</code> 语句块中。</p> <p>那么更新的思路是什么呢？前面说过了，只要想办法分别拿到组件产出的新旧 <code>VNode</code> 即可，这样我们就可以通过 <code>patch</code> 函数更新之。如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
    prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新</span>
        <span class="token comment">// prevVNode 是旧的组件VNode，nextVNode 是新的组件VNode</span>
        <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>prev
        <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>next
        <span class="token comment">// prevTree 是组件产出的旧的 VNode</span>
        <span class="token keyword">const</span> prevTree <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children
        <span class="token comment">// 更新 props 数据</span>
        <span class="token keyword">const</span> props <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
        <span class="token comment">// nextTree 是组件产出的新的 VNode</span>
        <span class="token keyword">const</span> nextTree <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 调用 patch 函数更新</span>
        <span class="token function">patch</span><span class="token punctuation">(</span>prevTree<span class="token punctuation">,</span> nextTree<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略...</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 立即调用 vnode.handle.update 完成初次挂载</span>
  vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>如上高亮代码所示，由于我们在 <code>patchComponent</code> 函数内已经更新过了 <code>handle</code> 对象，所以此时我们可以通过 <code>vnode.handle.prev</code> 和 <code>vnode.handle.next</code> 分别拿到旧的组件 <code>VNode</code> 和新的组件 <code>VNode</code>，但大家不要搞混的是：<code>prevVNode</code> 和 <code>nextVNode</code> 是用来描述函数式组件的 <code>VNode</code>，并非函数式组件所产出的 <code>VNode</code>。因为函数式组件所产出的 <code>VNode</code> 存放在用来描述函数式组件的 <code>VNode</code> 的 <code>children</code> 属性中，所以在如上代码中我们通过 <code>prevVNode.children</code> 拿到了组件所产出的旧的 <code>VNode</code> 即 <code>prevTree</code>，接着使用新的 <code>props</code> 重新调用组件函数 <code>nextVNode.tag(props)</code> 得到新产出的 <code>VNode</code> 即 <code>nextTree</code>，有了 <code>prevTree</code> 和 <code>nextTree</code> 之后我们就可以调用 <code>patch</code> 函数执行更新操作了。</p> <p>以上就是函数式组件的更新过程。</p> <h1 id="渲染器的核心-diff-算法"><a href="#渲染器的核心-diff-算法" class="header-anchor">#</a> 渲染器的核心 Diff 算法</h1> <h2 id="减小dom操作的性能开销"><a href="#减小dom操作的性能开销" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%87%8F%E5%B0%8Fdom%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 减小DOM操作的性能开销</h2> <p>上一章我们讨论了渲染器是如何更新各种类型的 <code>VNode</code> 的，实际上，上一章所讲解的内容归属于完整的 <code>Diff</code> 算法之内，但并不包含核心的 <code>Diff</code> 算法。那什么才是核心的 <code>Diff</code> 算法呢？看下图：</p> <p><img src="http://hcysun.me/vue-design/assets/img/patch-children-3.06453ea2.png" alt="img"></p> <p>我们曾在上一章中讲解子节点更新的时候见到过这张图，当时我们提到<strong>只有当新旧子节点的类型都是多个子节点时，核心 <code>Diff</code> 算法才派得上用场</strong>，并且当时我们采用了一种仅能实现目标但并不完美的算法：<strong>遍历旧的子节点，将其全部移除；再遍历新的子节点，将其全部添加</strong>，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 旧的 children 中有多个子节点</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 省略...</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 省略...</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点</span>
          <span class="token comment">// 遍历旧的子节点，将其全部移除</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 遍历新的子节点，将其全部添加</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>为了便于表述，我们把这个算法称为：<strong>简单 Diff 算法</strong>。<strong>简单 Diff 算法</strong>虽然能够达到目的，但并非最佳处理方式。我们经常会遇到可排序的列表，假设我们有一个由 <code>li</code> 标签组成的列表：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>列表中的 <code>li</code> 标签是 <code>ul</code> 标签的子节点，我们可以使用下面的数组来表示 <code>ul</code> 标签的 <code>children</code>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着由于数据变化导致了列表的顺序发生了变化，新的列表顺序如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>新的列表和旧的列表构成了新旧 <code>children</code>，当我们使用<strong>简单 Diff 算法</strong>更新这两个列表时，其操作行为可以用下图表示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-1.284cea98.png" alt="img"></p> <p>在这张图中我们使用圆形表示真实 DOM 元素，用菱形表示 <code>VNode</code>，旧的 <code>VNode</code> 保存着对真实 DOM 的引用(即 <code>vnode.el</code> 属性)，新的 <code>VNode</code> 是不存在对真实 DOM 的引用的。上图描述了<strong>简单 Diff 算法</strong>的操作行为，首先遍历旧的 <code>VNode</code>，通过旧 <code>VNode</code> 对真实 DOM 的引用取得真实 DOM，即可将已渲染的 DOM 移除。接着遍历新的 <code>VNode</code> 并将其全部添加到页面中。</p> <p>在这个过程中我们能够注意到：更新前后的真实 DOM 元素都是 <code>li</code> 标签。那么可不可以复用 <code>li</code> 标签呢？这样就能减少“移除”和“新建” DOM 元素带来的性能开销，实际上是可以的，我们在讲解 <code>pathcElement</code> 函数时了解到，当新旧 <code>VNode</code> 所描述的是相同标签时，那么这两个 <code>VNode</code> 之间的差异就仅存在于 <code>VNodeData</code> 和 <code>children</code> 上，所以我们完全可以通过遍历新旧 <code>VNode</code>，并一一比对它们，这样对于任何一个 DOM 元素来说，由于它们都是相同的标签，所以更新的过程是不会“移除”和“新建”任何 DOM 元素的，而是复用已有 DOM 元素，需要更新的只有 <code>VNodeData</code> 和 <code>children</code>。优化后的更新操作可以用下图表示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-2.8ce72d46.png" alt="img"></p> <p>用代码实现起来也非常简单，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 旧的 children 中有多个子节点</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 省略...</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 省略...</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">patch</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>通过遍历旧的 <code>children</code>，将新旧 <code>children</code> 中相同位置的节点拿出来作为一对“新旧 <code>VNode</code>”，并调用 <code>patch</code> 函数更新之。由于新旧列表的标签相同，所以这种更新方案较之前相比，省去了“移除”和“新建” DOM 元素的性能开销。而且从实现上看，代码也较之前少了一些，真可谓一举两得。但不要高兴的太早，细心的同学可能已经发现问题所在了，如上代码中我们遍历的是旧的 <code>children</code>，如果新旧 <code>children</code> 的长度相同的话，则这段代码可以正常工作，但是一旦新旧 <code>children</code> 的长度不同，这段代码就不能正常工作了，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-3.1d1958ef.png" alt="img"></p> <p>当新的 <code>children</code> 比旧的 <code>children</code> 的长度要长时，多出来的子节点是没办法应用 <code>patch</code> 函数的，此时我们应该把多出来的子节点作为新的节点添加上去。类似的，如果新的 <code>children</code> 比旧的 <code>children</code> 的长度要短时，我们应该把旧的 <code>children</code> 中多出来的子节点移除，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-4.0adb55a1.png" alt="img"></p> <p>通过分析我们得出一个规律，我们不应该总是遍历旧的 <code>children</code>，而是应该遍历新旧 <code>children</code> 中长度较短的那一个，这样我们能够做到尽可能多的应用 <code>patch</code> 函数进行更新，然后再对比新旧 <code>children</code> 的长度，如果新的 <code>children</code> 更长，则说明有新的节点需要添加，否则说明有旧的节点需要移除。最终我们得到如下实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 旧的 children 中有多个子节点</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 省略...</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 省略...</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点</span>
          <span class="token comment">// 获取公共长度，取新旧 children 长度较小的那一个</span>
          <span class="token keyword">const</span> prevLen <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length
          <span class="token keyword">const</span> nextLen <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length
          <span class="token keyword">const</span> commonLength <span class="token operator">=</span> prevLen <span class="token operator">&gt;</span> nextLen <span class="token operator">?</span> nextLen <span class="token operator">:</span> prevLen
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> commonLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">patch</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 如果 nextLen &gt; prevLen，将多出来的元素添加</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>nextLen <span class="token operator">&gt;</span> prevLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> commonLength<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prevLen <span class="token operator">&gt;</span> nextLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果 prevLen &gt; nextLen，将多出来的元素移除</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> commonLength<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/qqxxlxzwm6</p> <p><a href="https://codesandbox.io/s/qqxxlxzwm6" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>实际上，这个算法就是在没有 <code>key</code> 时所采用的算法，该算法是存在优化空间的，下面我们将分析如何进一步优化。</p> <h2 id="尽可能的复用-dom-元素"><a href="#尽可能的复用-dom-元素" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E5%A4%8D%E7%94%A8-dom-%E5%85%83%E7%B4%A0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 尽可能的复用 DOM 元素</h2> <h3 id="key-的作用"><a href="#key-的作用" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#key-%E7%9A%84%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> key 的作用</h3> <p>在上一小节中，我们通过减少 DOM 操作的次数使得更新的性能得到了提升，但它仍然存在可优化的空间，要明白如何优化，那首先我们需要知道问题出在哪里。还是拿上一节的例子来说，假设旧的 <code>children</code> 如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>新的 <code>children</code> 如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们来看一下，如果使用前面讲解的 <code>Diff</code> 算法来更新这对新旧 <code>children</code> 的话，会进行哪些操作：首先，旧 <code>children</code> 的第一个节点和新 <code>children</code> 的第一个节点进行比对(<code>patch</code>)，即：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">// vs</span>
<span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>patch</code> 函数知道它们是相同的标签，所以只会更新 <code>VNodeData</code> 和子节点，由于这两个标签都没有 <code>VNodeData</code>，所以只需要更新它们的子节点，旧的 <code>li</code> 元素的子节点是文本节点 <code>'1'</code>，而新的 <code>li</code> 标签的子节点是文本节点 <code>'3'</code>，所以最终会调用一次 <code>patchText</code> 函数将 <code>li</code> 标签的文本子节点由 <code>'1'</code> 更新为 <code>'3'</code>。接着，使用旧 <code>children</code> 的第二个节点和新 <code>children</code> 的第二个节点进行比对，结果同样是调用一次 <code>patchText</code> 函数用以更新 <code>li</code> 标签的文本子节点。类似的，对于新旧 <code>children</code> 的第三个节点同样也会调用一次 <code>patchText</code> 函数更新其文本子节点。而这，就是问题所在，实际上我们通过观察新旧 <code>children</code> 可以很容易的发现：新旧 <code>children</code> 中的节点只有顺序是不同的，所以最佳的操作应该是<strong>通过移动元素的位置来达到更新的目的</strong>。</p> <p>既然移动元素是最佳期望，那么我们就需要思考一下，能否通过移动元素来完成更新？能够移动元素的关键在于：我们需要在新旧 <code>children</code> 的节点中保存映射关系，以便我们能够在旧 <code>children</code> 的节点中找到可复用的节点。这时候我们就需要给 <code>children</code> 中的节点添加唯一标识，也就是我们常说的 <code>key</code>，在没有 <code>key</code> 的情况下，我们是没办法知道新 <code>children</code> 中的节点是否可以在旧 <code>children</code> 中找到可复用的节点的，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-5.ba7c26fa.png" alt="img"></p> <p>新旧 <code>children</code> 中的节点都是 <code>li</code> 标签，以新 <code>children</code> 的第一个 <code>li</code> 标签为例，你能说出在旧 <code>children</code> 中哪一个 <code>li</code> 标签可被它复用吗？不能，所以，为了明确的知道新旧 <code>children</code> 中节点的映射关系，我们需要在 <code>VNode</code> 创建伊始就为其添加唯一的标识，即 <code>key</code> 属性。</p> <p>我们可以在使用 <code>h</code> 函数创建 <code>VNode</code> 时，通过 <code>VNodeData</code> 为即将创建的 <code>VNode</code> 设置一个 <code>key</code>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'a'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>但是为了 <code>diff</code> 算法更加方便的读取一个 <code>VNode</code> 的 <code>key</code>，我们应该在创建 <code>VNode</code> 时将 <code>VNodeData</code> 中的 <code>key</code> 添加到 <code>VNode</code> 本身，所以我们需要修改一下 <code>h</code> 函数，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>

  <span class="token comment">// 返回 VNode 对象</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    flags<span class="token punctuation">,</span>
    tag<span class="token punctuation">,</span>
    data<span class="token punctuation">,</span>
    key<span class="token operator">:</span> data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>key <span class="token operator">?</span> data<span class="token punctuation">.</span>key <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token punctuation">,</span>
    childFlags<span class="token punctuation">,</span>
    el<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>如上代码所示，我们在创建 <code>VNode</code> 时，如果 <code>VNodeData</code> 中存在 <code>key</code> 属性，则我们会把其添加到 <code>VNode</code> 对象本身。</p> <p>现在，在创建 <code>VNode</code> 时已经可以为 <code>VNode</code> 添加唯一标识了，我们使用 <code>key</code> 来修改之前的例子，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 旧 children</span>
<span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'a'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'b'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'c'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>

<span class="token comment">// 新 children</span>
<span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'c'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'a'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'b'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>有了 <code>key</code> 我们就能够明确的知道新旧 <code>children</code> 中节点的映射关系，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-6.1e914878.png" alt="img"></p> <p>知道了映射关系，我们就很容易判断新 <code>children</code> 中的节点是否可被复用：只需要遍历新 <code>children</code> 中的每一个节点，并去旧 <code>children</code> 中寻找是否存在具有相同 <code>key</code> 值的节点，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 遍历新的 children</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 遍历旧的 children</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token comment">// 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token keyword">break</span> <span class="token comment">// 这里需要 break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这段代码中有两层嵌套的 <code>for</code> 循环语句，外层循环用于遍历新 <code>children</code>，内层循环用于遍历旧 <code>children</code>，其目的是尝试寻找具有相同 <code>key</code> 值的两个节点，如果找到了，则认为新 <code>children</code> 中的节点可以复用旧 <code>children</code> 中已存在的节点，这时我们仍然需要调用 <code>patch</code> 函数对节点进行更新，如果新节点相对于旧节点的 <code>VNodeData</code> 和子节点都没有变化，则 <code>patch</code> 函数什么都不会做(这是优化的关键所在)，如果新节点相对于旧节点的 <code>VNodeData</code> 或子节点有变化，则 <code>patch</code> 函数保证了更新的正确性。</p> <h3 id="找到需要移动的节点"><a href="#找到需要移动的节点" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E7%A7%BB%E5%8A%A8%E7%9A%84%E8%8A%82%E7%82%B9" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 找到需要移动的节点</h3> <p>现在我们已经找到了可复用的节点，并进行了合适的更新操作，下一步需要做的，就是判断一个节点是否需要移动以及如何移动。如何判断节点是否需要移动呢？为了弄明白这个问题，我们可以先考虑不需要移动的情况，当新旧 <code>children</code> 中的节点顺序不变时，就不需要额外的移动操作，如下：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-1.7b07877f.png" alt="img"></p> <p>上图中的数字代表着节点在旧 <code>children</code> 中的索引，我们来尝试执行一下本节介绍的算法，看看会发生什么：</p> <ul><li>1、取出新 <code>children</code> 的第一个节点，即 <code>li-a</code>，并尝试在旧 <code>children</code> 中寻找 <code>li-a</code>，结果是我们找到了，并且 <code>li-a</code> 在旧 <code>children</code> 中的索引为 <code>0</code>。</li> <li>2、取出新 <code>children</code> 的第二个节点，即 <code>li-b</code>，并尝试在旧 <code>children</code> 中寻找 <code>li-b</code>，也找到了，并且 <code>li-b</code> 在旧 <code>children</code> 中的索引为 <code>1</code>。</li> <li>3、取出新 <code>children</code> 的第三个节点，即 <code>li-c</code>，并尝试在旧 <code>children</code> 中寻找 <code>li-c</code>，同样找到了，并且 <code>li-c</code> 在旧 <code>children</code> 中的索引为 <code>2</code>。</li></ul> <p>总结一下我们在“寻找”的过程中，先后遇到的索引顺序为：<code>0</code>-&gt;<code>1</code>-&gt;<code>2</code>。这是一个递增的顺序，这说明<strong>如果在寻找的过程中遇到的索引呈现递增趋势，则说明新旧 <code>children</code> 中节点顺序相同，不需要移动操作</strong>。相反的，<strong>如果在寻找的过程中遇到的索引值不呈现递增趋势，则说明需要移动操作</strong>，举个例子，下图展示了新旧 <code>children</code> 中的节点顺序不一致的情况：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-2.e6cef98d.png" alt="img"></p> <p>我们同样执行一下本节介绍的算法，看看会发生什么：</p> <ul><li>1、取出新 <code>children</code> 的第一个节点，即 <code>li-c</code>，并尝试在旧 <code>children</code> 中寻找 <code>li-c</code>，结果是我们找到了，并且 <code>li-c</code> 在旧 <code>children</code> 中的索引为 <code>2</code>。</li> <li>2、取出新 <code>children</code> 的第二个节点，即 <code>li-a</code>，并尝试在旧 <code>children</code> 中寻找 <code>li-a</code>，也找到了，并且 <code>li-a</code> 在旧 <code>children</code> 中的索引为 <code>0</code>。</li></ul> <p>到了这里，<strong>递增</strong>的趋势被打破了，我们在寻找的过程中先遇到的索引值是 <code>2</code>，接着又遇到了比 <code>2</code> 小的 <code>0</code>，这说明<strong>在旧 <code>children</code> 中 <code>li-a</code> 的位置要比 <code>li-c</code> 靠前，但在新的 <code>children</code> 中 <code>li-a</code> 的位置要比 <code>li-c</code> 靠后</strong>。这时我们就知道了 <code>li-a</code> 是那个需要被移动的节点，我们接着往下执行。</p> <ul><li>3、取出新 <code>children</code> 的第三个节点，即 <code>li-b</code>，并尝试在旧 <code>children</code> 中寻找 <code>li-b</code>，同样找到了，并且 <code>li-b</code> 在旧 <code>children</code> 中的索引为 <code>1</code>。</li></ul> <p>我们发现 <code>1</code> 同样小于 <code>2</code>，这说明<strong>在旧 <code>children</code> 中节点 <code>li-b</code> 的位置也要比 <code>li-c</code> 的位置靠前，但在新的 <code>children</code> 中 <code>li-b</code> 的位置要比 <code>li-c</code> 靠后</strong>。所以 <code>li-b</code> 也需要被移动。</p> <p>以上我们过程就是我们寻找需要移动的节点的过程，在这个过程中我们发现一个重要的数字：<code>2</code>，是这个数字的存在才使得我们能够知道哪些节点需要移动，我们可以给这个数字一个名字，叫做：<strong>寻找过程中在旧 <code>children</code> 中所遇到的最大索引值</strong>。如果在后续寻找的过程中发现存在索引值比<strong>最大索引值</strong>小的节点，意味着该节点需要被移动。</p> <p>实际上，这就是 <code>React</code> 所使用的算法。我们可以使用一个叫做 <code>lastIndex</code> 的变量存储寻找过程中遇到的最大索引值，并且它的初始值为 <code>0</code>，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 用来存储寻找过程中遇到的最大索引值</span>
<span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
<span class="token comment">// 遍历新的 children</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 遍历旧的 children</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token comment">// 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 需要移动</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新 lastIndex</span>
        lastIndex <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span> <span class="token comment">// 这里需要 break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>如上代码中，变量 <code>j</code> 是节点在旧 <code>children</code> 中的索引，如果它小于 <code>lastIndex</code> 则代表当前遍历到的节点需要移动，否则我们就使用 <code>j</code> 的值更新 <code>lastIndex</code> 变量的值，这就保证了 <code>lastIndex</code> 所存储的总是我们在旧 <code>children</code> 中所遇到的最大索引。</p> <h3 id="移动节点"><a href="#移动节点" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E7%A7%BB%E5%8A%A8%E8%8A%82%E7%82%B9" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 移动节点</h3> <p>现在我们已经有办法找到需要移动的节点了，接下来要解决的问题就是：应该如何移动这些节点？为了弄明白这个问题，我们还是先来看下图：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-2.e6cef98d.png" alt="img"></p> <p>新 <code>children</code> 中的第一个节点是 <code>li-c</code>，它在旧 <code>children</code> 中的索引为 <code>2</code>，由于 <code>li-c</code> 是新 <code>children</code> 中的第一个节点，所以它始终都是不需要移动的，只需要调用 <code>patch</code> 函数更新即可，如下图：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-3.dbc9ff62.png" alt="img"></p> <p>这里我们需要注意的，也是非常重要的一点是：<strong>新 <code>children</code> 中的 <code>li-c</code> 节点在经过 <code>patch</code> 函数之后，也将存在对真实 DOM 元素的引用</strong>。下面的代码可以证明这一点：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>

  <span class="token comment">// 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>

<span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如上代码所示，这是 <code>patchElement</code> 函数中的一段代码，在更新<strong>新旧</strong> <code>VNode</code> 时，新的 <code>VNode</code> 通过旧 <code>VNode</code> 的 <code>el</code> 属性实现了对真实 DOM 的引用。为什么说这一点很关键呢？继续往下看。</p> <p><code>li-c</code> 节点更新完毕，接下来是新 <code>children</code> 中的第二个节点 <code>li-a</code>，它在旧 <code>children</code> 中的索引是 <code>0</code>，由于 <code>0 &lt; 2</code> 所以 <code>li-a</code> 是需要移动的节点，那应该怎么移动呢？很简单，新 <code>children</code> 中的节点顺序实际上就是更新完成之后，节点应有的最终顺序，通过观察新 <code>children</code> 可知，新 <code>children</code> 中 <code>li-a</code> 节点的前一个节点是 <code>li-c</code>，所以我们的移动方案应该是：<strong>把 <code>li-a</code> 节点对应的真实 DOM 移动到 <code>li-c</code> 节点所对应真实 DOM 的后面</strong>。这里的关键在于<strong>移动的是真实 DOM 而非 VNode</strong>。所以我们需要分别拿到 <code>li-c</code> 和 <code>li-a</code> 所对应的真实 DOM，这时就体现出了上面提到的关键点：<strong>新 <code>children</code> 中的 <code>li-c</code> 已经存在对真实 DOM 的引用了</strong>，所以我们很容易就能拿到 <code>li-c</code> 对应的真实 DOM。对于获取 <code>li-a</code> 节点所对应的真实 DOM 将更加容易，由于我们当前遍历到的节点就是 <code>li-a</code>，所以我们可以直接通过旧 <code>children</code> 中的 <code>li-a</code> 节点拿到其真实 DOM 的引用，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 用来存储寻找过程中遇到的最大索引值</span>
<span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
<span class="token comment">// 遍历新的 children</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 遍历旧的 children</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token comment">// 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 需要移动</span>
        <span class="token comment">// refNode 是为了下面调用 insertBefore 函数准备的</span>
        <span class="token keyword">const</span> refNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
        <span class="token comment">// 调用 insertBefore 函数移动 DOM</span>
        container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新 lastIndex</span>
        lastIndex <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span> <span class="token comment">// 这里需要 break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>观察如上代码段中高亮的部分，实际上这两句代码即可完成 DOM 的移动操作。我们来对这两句代码的工作方式做一个详细的解释，假设我们当前正在更新的节点是 <code>li-a</code>，那么如上代码中的变量 <code>i</code> 就是节点 <code>li-a</code> 在新 <code>children</code> 中的位置索引。所以 <code>nextChildren[i - 1]</code> 就是 <code>li-a</code> 节点的前一个节点，也就是 <code>li-c</code> 节点，由于 <code>li-c</code> 节点存在对真实 DOM 的引用，所以我们可以通过其 <code>el</code> 属性拿到真实 DOM，到了这一步，<code>li-c</code> 节点的所对应的真实 DOM 我们已经得到了。但不要忘记我们的目标是：<strong>把 <code>li-a</code> 节点对应的真实 DOM 移动到 <code>li-c</code> 节点所对应真实 DOM 的后面</strong>，所以我们的思路应该是<strong>想办法拿到 <code>li-c</code> 节点对应真实 DOM 的下一个兄弟节点，并把 <code>li-a</code> 节点所对应真实 DOM 插到该节点的前面</strong>，这才能保证移动的正确性。所以上面的代码中常量 <code>refNode</code> 引用是 <code>li-c</code> 节点对应真实 DOM 的下一个兄弟节点。拿到了正确的 <code>refNode</code> 之后，我们就可以调用容器元素的 <code>insertBefore</code> 方法来完成 DOM 的移动了，移动的对象就是 <code>li-a</code> 节点所对应的真实 DOM，由于当前正在处理的就是 <code>li-a</code> 节点，所以 <code>prevVNode</code> 就是旧 <code>children</code> 中的 <code>li-a</code> 节点，它是存在对真实 DOM 的引用的，即 <code>prevVNode.el</code>。万事俱备，移动工作将顺利完成。说起来有些抽象，用一张图可以更加清晰的描述这个过程：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-4.7443f559.png" alt="img"></p> <p>观察不同颜色的线条，关键在于我们要找到 <code>VNode</code> 所引用的真实 DOM，然后把真实 DOM 按照新 <code>children</code> 中节点间的关系进行移动，由于新 <code>children</code> 中节点的顺序就是最终的目标顺序，所以移动之后的真实 DOM 的顺序也会是最终的目标顺序。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/4x6qo5w34w</p> <p><a href="https://codesandbox.io/s/4x6qo5w34w" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="添加新元素"><a href="#添加新元素" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 添加新元素</h3> <p>在上面的讲解中，我们一直忽略了一个问题，即新 <code>children</code> 中可能包含那些不能够通过移动来完成更新的节点，例如新 <code>children</code> 中包含了一个全新的节点，这意味着在旧 <code>children</code> 中是找不到该节点的，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-5.d12b2ed9.png" alt="img"></p> <p>节点 <code>li-d</code> 在旧的 <code>children</code> 中是不存在的，所以当我们尝试在旧的 <code>children</code> 中寻找 <code>li-d</code> 节点时，是找不到可复用节点的，这时就没办法通过移动节点来完成更新操作，所以我们应该使用 <code>mount</code> 函数将 <code>li-d</code> 节点作为全新的 <code>VNode</code> 挂载到合适的位置。</p> <p>我们将面临两个问题，第一个问题是：如何知道一个节点在旧的 <code>children</code> 中是不存在的？这个问题比较好解决，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    find <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      find <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 需要移动</span>
        <span class="token keyword">const</span> refNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
        container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新 lastIndex</span>
        lastIndex <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>如上高亮代码所示，我们在原来的基础上添加了变量 <code>find</code>，它将作为一个标志，代表新 <code>children</code> 中的节点是否存在于旧 <code>children</code> 中，初始值为 <code>false</code>，一旦在旧 <code>children</code> 中寻找到了相应的节点，我们就将变量 <code>find</code> 的值设置为 <code>true</code>，所以<strong>如果内层循环结束后，变量 <code>find</code> 的值仍然为 <code>false</code>，则说明在旧的 <code>children</code> 中找不到可复用的节点</strong>，这时我们就需要使用 <code>mount</code> 函数将当前遍历到的节点挂载到容器元素，如下高亮的代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    find <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      find <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 需要移动</span>
        <span class="token keyword">const</span> refNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
        container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新 lastIndex</span>
        lastIndex <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 挂载新节点</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>当内层循环结束之后，如果变量 <code>find</code> 的值仍然为 <code>false</code>，则说明 <code>nextVNode</code> 是全新的节点，所以我们直接调用 <code>mount</code> 函数将其挂载到容器元素 <code>container</code> 中。但是很遗憾，这段代码不能正常的工作，这是因为<strong>我们之前编写的 <code>mountElement</code> 函数存在缺陷，它总是调用 <code>appendChild</code> 方法插入 DOM 元素</strong>，所以上面的代码始终会把新的节点作为容器元素的最后一个子节点添加到末尾，这不是我们想要的结果，我们应该按照节点在新的 <code>children</code> 中的位置将其添加到正确的地方，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-5.d12b2ed9.png" alt="img"></p> <p>新的 <code>li-d</code> 节点紧跟在 <code>li-a</code> 节点的后面，所以正确的做法应该是把 <code>li-d</code> 节点添加到 <code>li-a</code> 节点所对应真实 DOM 的后面才行。如何才能保证 <code>li-d</code> 节点始终被添加到 <code>li-a</code> 节点的后面呢？答案是使用 <code>insertBefore</code> 方法代替 <code>appendChild</code> 方法，我们可以找到 <code>li-a</code> 节点所对应真实 DOM 的下一个节点，然后将 <code>li-d</code> 节点插入到该节点之前即可，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    find <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      find <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 需要移动</span>
        <span class="token keyword">const</span> refNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
        container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新 lastIndex</span>
        lastIndex <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 挂载新节点</span>
    <span class="token comment">// 找到 refNode</span>
    <span class="token keyword">const</span> refNode <span class="token operator">=</span>
      i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span>
        <span class="token operator">?</span> prevChildren<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el
        <span class="token operator">:</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
    <span class="token function">mount</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>我们先找到当前遍历到的节点的前一个节点，即 <code>nextChildren[i - 1]</code>，接着找到该节点所对应真实 DOM 的下一个子节点作为 <code>refNode</code>，即 <code>nextChildren[i - 1].el.nextSibling</code>，但是由于当前遍历到的节点有可能是新 <code>children</code> 的第一个节点，这时 <code>i - 1 &lt; 0</code>，这将导致 <code>nextChildren[i - 1]</code> 不存在，所以当 <code>i - 1 &lt; 0</code> 时，我们就知道<strong>新的节点是作为第一个节点而存在的</strong>，这时我们只需要把新的节点插入到最前面即可，所以我们使用 <code>prevChildren[0].el</code> 作为 <code>refNode</code>。最后调用 <code>mount</code> 函数挂载新节点时，我们为其传递了第四个参数 <code>refNode</code>，当 <code>refNode</code> 存在时，我们应该使用 <code>insertBefore</code> 方法代替 <code>appendChild</code> 方法，这就需要我们修改之前实现的 <code>mount</code> 函数了 <code>mountElement</code> 函数，为它们添加第四个参数，如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// mount 函数</span>
<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> flags <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
  <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 挂载普通标签</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>

<span class="token comment">// mountElement 函数</span>
<span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>

  refNode <span class="token operator">?</span> container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span> <span class="token operator">:</span> container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>这样，当新 <code>children</code> 中存在全新的节点时，我们就能够保证正确的将其添加到容器元素内了。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/54215km3vn</p> <p><a href="https://codesandbox.io/s/54215km3vn" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>TIP</p> <p>实际上，所有与挂载和 <code>patch</code> 相关的函数都应该接收 <code>refNode</code> 作为参数，这里我们旨在让读者掌握核心思路，避免讲解过程的冗杂。</p> <h3 id="移除不存在的元素"><a href="#移除不存在的元素" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%83%E7%B4%A0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 移除不存在的元素</h3> <p>除了要将全新的节点添加到容器元素之外，我们还应该把已经不存在了的节点移除，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-6.4ad1a4c1.png" alt="img"></p> <p>可以看出，新的 <code>children</code> 中已经不存在 <code>li-c</code> 节点了，所以我们应该想办法将 <code>li-c</code> 节点对应的真实 DOM 从容器元素内移除。但我们之前编写的算法还不能完成这个任务，因为外层循环遍历的是新的 <code>children</code>，所以外层循环会执行两次，第一次用于处理 <code>li-a</code> 节点，第二次用于处理 <code>li-b</code> 节点，此时整个算法已经运行结束了。所以，我们需要在外层循环结束之后，再优先遍历一次旧的 <code>children</code>，并尝试拿着旧 <code>children</code> 中的节点去新 <code>children</code> 中寻找相同的节点，如果找不到则说明该节点已经不存在于新 <code>children</code> 中了，这时我们应该将该节点对应的真实 DOM 移除，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    find <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 挂载新节点</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 移除已经不存在的节点</span>
<span class="token comment">// 遍历旧的节点</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token comment">// 拿着旧 VNode 去新 children 中寻找相同的节点</span>
  <span class="token keyword">const</span> has <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>
    <span class="token parameter">nextVNode</span> <span class="token operator">=&gt;</span> nextVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> prevVNode<span class="token punctuation">.</span>key
  <span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>has<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有找到相同的节点，则移除</span>
    container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/844lp3mq72</p> <p><a href="https://codesandbox.io/s/844lp3mq72" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>至此，第一个完整的 <code>Diff</code> 算法我们就讲解完毕了，这个算法就是 <code>React</code> 所采用的 <code>Diff</code> 算法。但该算法仍然存在可优化的空间，我们将在下一小节继续讨论。</p> <h2 id="另一个思路-双端比较"><a href="#另一个思路-双端比较" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%80%9D%E8%B7%AF-%E5%8F%8C%E7%AB%AF%E6%AF%94%E8%BE%83" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 另一个思路 - 双端比较</h2> <h3 id="双端比较的原理"><a href="#双端比较的原理" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%8F%8C%E7%AB%AF%E6%AF%94%E8%BE%83%E7%9A%84%E5%8E%9F%E7%90%86" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 双端比较的原理</h3> <p>刚刚提到了 <code>React</code> 的 <code>Diff</code> 算法是存在优化空间的，想要要找到优化的关键点，我们首先要知道它存在什么问题。来看下图：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-1.216b174f.png" alt="img"></p> <p>在这个例子中，我们可以通过肉眼观察从而得知最优的解决方案应该是：<strong>把 <code>li-c</code> 节点对应的真实 DOM 移动到最前面即可</strong>，只需要一次移动即可完成更新。然而，<code>React</code> 所采用的 <code>Diff</code> 算法在更新如上案例的时候，会进行两次移动：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-2.65a1bd51.png" alt="img"></p> <p>显然，这种做法必然会造成额外的性能开销。那么有没有办法来避免这种多余的 DOM 移动呢？当然有办法，那就是我们接下来要介绍的一个新的思路：<strong>双端比较</strong>。</p> <p>所谓双端比较，就是同时从新旧 <code>children</code> 的两端开始进行比较的一种方式，所以我们需要四个索引值，分别指向新旧 <code>children</code> 的两端，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-3.933b8708.png" alt="img"></p> <p>我们使用四个变量 <code>oldStartIdx</code>、<code>oldEndIdx</code>、<code>newStartIdx</code> 以及 <code>newEndIdx</code> 分别存储旧 <code>children</code> 和新 <code>children</code> 的两个端点的位置索引，可以用如下代码来表示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> oldStartIdx <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">let</span> oldEndIdx <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
<span class="token keyword">let</span> newStartIdx <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">let</span> newEndIdx <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>除了位置索引之外，我们还需要拿到四个位置索引所指向的 <code>VNode</code>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> oldStartVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIdx<span class="token punctuation">]</span>
<span class="token keyword">let</span> oldEndVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIdx<span class="token punctuation">]</span>
<span class="token keyword">let</span> newStartVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIdx<span class="token punctuation">]</span>
<span class="token keyword">let</span> newEndVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIdx<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>有了这些基础信息，我们就可以开始执行双端比较了，在一次比较过程中，最多需要进行四次比较：</p> <ul><li>1、使用旧 <code>children</code> 的头一个 <code>VNode</code> 与新 <code>children</code> 的头一个 <code>VNode</code> 比对，即 <code>oldStartVNode</code> 和 <code>newStartVNode</code> 比较对。</li> <li>2、使用旧 <code>children</code> 的最后一个 <code>VNode</code> 与新 <code>children</code> 的最后一个 <code>VNode</code> 比对，即 <code>oldEndVNode</code> 和 <code>newEndVNode</code> 比对。</li> <li>3、使用旧 <code>children</code> 的头一个 <code>VNode</code> 与新 <code>children</code> 的最后一个 <code>VNode</code> 比对，即 <code>oldStartVNode</code> 和 <code>newEndVNode</code> 比对。</li> <li>4、使用旧 <code>children</code> 的最后一个 <code>VNode</code> 与新 <code>children</code> 的头一个 <code>VNode</code> 比对，即 <code>oldEndVNode</code> 和 <code>newStartVNode</code> 比对。</li></ul> <p>在如上四步比对过程中，试图去寻找可复用的节点，即拥有相同 <code>key</code> 值的节点。这四步比对中，在任何一步中寻找到了可复用节点，则会停止后续的步骤，可以用下图来描述在一次比对过程中的四个步骤：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-4.b1c3cc2a.png" alt="img"></p> <p>如下代码是该比对过程的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤二：oldEndVNode 和 newEndVNode 比对</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤三：oldStartVNode 和 newEndVNode 比对</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>每次比对完成之后，如果在某一步骤中找到了可复用的节点，我们就需要将相应的位置索引<strong>后移/前移</strong>一位。以上图为例：</p> <ul><li>第一步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-d</code> 进行比对，由于二者 <code>key</code> 值不同，所以不可复用，什么都不做。</li> <li>第二步：拿旧 <code>children</code> 中的 <code>li-d</code> 和新 <code>children</code> 中的 <code>li-c</code> 进行比对，同样不可复用，什么都不做。</li> <li>第三步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-c</code> 进行比对，什么都不做。</li> <li>第四部：拿旧 <code>children</code> 中的 <code>li-d</code> 和新 <code>children</code> 中的 <code>li-d</code> 进行比对，由于这两个节点拥有相同的 <code>key</code> 值，所以我们在这次比对的过程中找到了可复用的节点。</li></ul> <p>由于我们在第四步的比对中找到了可复用的节点，即 <code>oldEndVNode</code> 和 <code>newStartVNode</code> 拥有相同的 <code>key</code> 值，这说明：<strong><code>li-d</code> 节点所对应的真实 DOM 原本是最后一个子节点，并且更新之后它应该变成第一个子节点</strong>。所以我们需要把 <code>li-d</code> 所对应的真实 DOM 移动到最前方即可：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤二：oldEndVNode 和 newEndVNode 比对</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤三：oldStartVNode 和 newEndVNode 比对</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span>

  <span class="token comment">// 先调用 patch 函数完成更新</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">,</span> newStartVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token comment">// 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点</span>
  container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 更新索引，指向下一个位置</span>
  oldEndVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
  newStartVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>这一步更新完成之后，新的索引关系可以用下图来表示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-5.0c42d714.png" alt="img"></p> <p>由于 <code>li-d</code> 节点所对应的真实 DOM 元素已经更新完成且被移动，所以现在真实 DOM 的顺序是：<code>li-d</code>、<code>li-a</code>、<code>li-b</code>、<code>li-c</code>，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-6.80733f9c.png" alt="img"></p> <p>这样，一次比对就完成了，并且位置索引已经更新，我们需要进行下轮的比对，那么什么时候比对才能结束呢？如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤二：oldEndVNode 和 newEndVNode 比对</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤三：oldStartVNode 和 newEndVNode 比对</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>我们将每一轮比对所做的工作封装到一个 <code>while</code> 循环内，循环结束的条件是要么 <code>oldStartIdx</code> 大于 <code>oldEndIdx</code>，要么 <code>newStartIdx</code> 大于 <code>newEndIdx</code>。</p> <p>还是观察上图，我们继续进行第二轮的比对：</p> <ul><li>第一步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-b</code> 进行比对，由于二者 <code>key</code> 值不同，所以不可复用，什么都不做。</li> <li>第二步：拿旧 <code>children</code> 中的 <code>li-c</code> 和新 <code>children</code> 中的 <code>li-c</code> 进行比对，此时，由于二者拥有相同的 <code>key</code>，所以是可复用的节点，但是由于二者在新旧 <code>children</code> 中都是最末尾的一个节点，所以是不需要进行移动操作的，只需要调用 <code>patch</code> 函数更新即可，同时将相应的索引前移一位，如下高亮代码所示：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤二：oldEndVNode 和 newEndVNode 比对</span>

    <span class="token comment">// 调用 patch 函数更新</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">,</span> newEndVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token comment">// 更新索引，指向下一个位置</span>
    oldEndVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
    newEndVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤三：oldStartVNode 和 newEndVNode 比对</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span>

    <span class="token comment">// 先调用 patch 函数完成更新</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">,</span> newStartVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token comment">// 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点</span>
    container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token comment">// 更新索引，指向下一个位置</span>
    oldEndVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
    newStartVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>由于没有进行移动操作，所以在这一轮比对中，真实 DOM 的顺序没有发生变化，下图表示了在这一轮比对结束之后的状况：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-7.6474272b.png" alt="img"></p> <p>由于此时循环条件成立，所以会继续下一轮的比较：</p> <ul><li>第一步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-b</code> 进行比对，由于二者 <code>key</code> 值不同，所以不可复用，什么都不做。</li> <li>第二步：拿旧 <code>children</code> 中的 <code>li-b</code> 和新 <code>children</code> 中的 <code>li-a</code> 进行比对，不可复用，什么都不做。</li> <li>第三步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-a</code> 进行比对，此时，我们找到了可复用的节点。</li></ul> <p>这一次满足的条件是：<strong><code>oldStartVNode.key === newEndVNode.key</code></strong>，这说明：<strong><code>li-a</code> 节点所对应的真实 DOM 原本是第一个子节点，但现在变成了“最后”一个子节点</strong>，这里的“最后”一词使用了引号，这是因为大家要明白“最后”的真正含义，它并不是指真正意义上的最后一个节点，而是指当前索引范围内的最后一个节点。所以移动操作也是比较明显的，我们将 <code>oldStartVNode</code> 对应的真实 DOM 移动到 <code>oldEndVNode</code> 所对应真实 DOM 的后面即可，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤二：oldEndVNode 和 newEndVNode 比对</span>

    <span class="token comment">// 调用 patch 函数更新</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">,</span> newEndVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token comment">// 更新索引，指向下一个位置</span>
    oldEndVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
    newEndVNode <span class="token operator">=</span> newEndVNode<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤三：oldStartVNode 和 newEndVNode 比对</span>

    <span class="token comment">// 调用 patch 函数更新</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">,</span> newEndVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token comment">// 将 oldStartVNode.el 移动到 oldEndVNode.el 的后面，也就是 oldEndVNode.el.nextSibling 的前面</span>
    container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>
      oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span>
      oldEndVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
    <span class="token punctuation">)</span>
    <span class="token comment">// 更新索引，指向下一个位置</span>
    oldStartVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
    newEndVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span>

    <span class="token comment">// 先调用 patch 函数完成更新</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">,</span> newStartVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token comment">// 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点</span>
    container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token comment">// 更新索引，指向下一个位置</span>
    oldEndVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
    newStartVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>在这一步的更新中，真实 DOM 的顺序是有变化的，<code>li-a</code> 节点对应的真实 DOM 被移到了 <code>li-b</code> 节点对应真实 DOM 的后面，同时由于位置索引也在相应的移动，所以在这一轮更新之后，现在的结果看上去应该如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-8.562f3899.png" alt="img"></p> <p>现在 <code>oldStartIdx</code> 和 <code>oldEndIdx</code> 指向了同一个位置，即旧 <code>children</code> 中的 <code>li-b</code> 节点。同样的 <code>newStartIdx</code> 和 <code>newEndIdx</code> 也指向了同样的位置，即新 <code>children</code> 中的 <code>li-b</code>。由于此时仍然满足循环条件，所以会继续下一轮的比对：</p> <ul><li>第一步：拿旧 <code>children</code> 中的 <code>li-b</code> 和新 <code>children</code> 中的 <code>li-b</code> 进行比对，二者拥有相同的 <code>key</code>，可复用。</li></ul> <p>此时，在第一步的时候就已经找到了可复用的节点，满足的条件是：<strong>oldStartVNode.key === newStartVNode.key</strong>，但是由于该节点无论是在新 <code>children</code> 中还是旧 <code>children</code> 中，都是“第一个”节点，所以位置不需要变化，即不需要移动操作，只需要调用 <code>patch</code> 函数更新即可，同时也要将相应的位置所以下移一位，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span>

    <span class="token comment">// 调用 patch 函数更新</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">,</span> newStartVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token comment">// 更新索引，指向下一个位置</span>
    oldStartVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
    newStartVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在这一轮更新完成之后，虽然没有进行任何移动操作，但是我们发现，真实 DOM 的顺序，已经与新 <code>children</code> 中节点的顺序保持一致了，也就是说我们圆满的完成了目标，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-9.532508e2.png" alt="img"></p> <p>另外，观察上图可以发现，此时 <code>oldStartIdx</code> 和 <code>newStartIdx</code> 分别比 <code>oldEndIdx</code> 和 <code>newEndIdx</code> 要大，所以这将是最后一轮的比对，循环将终止，以上就是双端比较的核心原理。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/xvmqn58jqw</p> <p><a href="https://codesandbox.io/s/xvmqn58jqw" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="双端比较的优势"><a href="#双端比较的优势" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%8F%8C%E7%AB%AF%E6%AF%94%E8%BE%83%E7%9A%84%E4%BC%98%E5%8A%BF" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 双端比较的优势</h3> <p>理解了双端比较的原理之后，我们来看一下双端比较所带来的优势，还是拿之前的例子，如下：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-react-2.e6cef98d.png" alt="img"></p> <p>前面分析过，如果采用 <code>React</code> 的方式来对上例进行更新，则会执行两次移动操作，首先会把 <code>li-a</code> 节点对应的真实 DOM 移动到 <code>li-c</code> 节点对应的真实 DOM 的后面，接着再把 <code>li-b</code> 节点所对应的真实 DOM 移动到 <code>li-a</code> 节点所对应真实 DOM 的后面，即：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-2.65a1bd51.png" alt="img"></p> <p>接下来我们采用双端比较的方式，来完成上例的更新，看看会有什么不同，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-10.2a5c7497.png" alt="img"></p> <p>我们按照双端比较的思路开始第一轮比较，按步骤执行：</p> <ul><li>第一步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-c</code> 进行比对，由于二者 <code>key</code> 值不同，所以不可复用，什么都不做。</li> <li>第二步：拿旧 <code>children</code> 中的 <code>li-c</code> 和新 <code>children</code> 中的 <code>li-b</code> 进行比对，不可复用，什么都不做。</li> <li>第三步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-b</code> 进行比对，不可复用，什么都不做。</li> <li>第四步：拿旧 <code>children</code> 中的 <code>li-c</code> 和新 <code>children</code> 中的 <code>li-c</code> 进行比对，此时，两个节点拥有相同的 <code>key</code> 值，可复用。</li></ul> <p>到了第四步，对于 <code>li-c</code> 节点来说，它原本是整个 <code>children</code> 的最后一个子节点，但是现在变成了新 <code>children</code> 的第一个子节点，按照上端比较的算法逻辑，此时会把 <code>li-c</code> 节点所对应的真实 DOM 移动到 <code>li-a</code> 节点所对应真实 DOM 的前面，即：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-11.dfc7860f.png" alt="img"></p> <p>可以看到，我们只通过一次 DOM 移动，就使得真实 DOM 的顺序与新 <code>children</code> 中节点的顺序一致，完成了更新。换句话说，双端比较在移动 DOM 方面更具有普适性，不会因为 DOM 结构的差异而产生影响。</p> <h3 id="非理想情况的处理方式"><a href="#非理想情况的处理方式" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E9%9D%9E%E7%90%86%E6%83%B3%E6%83%85%E5%86%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 非理想情况的处理方式</h3> <p>在之前的讲解中，我们所采用的是较理想的例子，换句话说，在每一轮的比对过程中，总会满足四个步骤中的一步，但实际上大多数情况下并不会这么理想，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-12.06bed8e2.png" alt="img"></p> <p>上图中 ①、②、③、④ 这四步中的每一步比对，都无法找到可复用的节点，这时应该怎么办呢？没办法，我们只能拿新 <code>children</code> 中的第一个节点尝试去旧 <code>children</code> 中寻找，试图找到拥有相同 <code>key</code> 值的节点，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素</span>
    <span class="token keyword">const</span> idxInOld <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>
      <span class="token parameter">node</span> <span class="token operator">=&gt;</span> node<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这段代码增加了 <code>else</code> 分支，用来处理在四个步骤的比对中都没有成功的情况，我们遍历了旧的 <code>children</code>，并试图找到与新 <code>children</code> 中第一个节点拥有相同 <code>key</code> 值的节点，并把该节点在旧 <code>children</code> 中的位置索引记录下来，存储到 <code>idxInOld</code> 常量中。这里的关键点并不在于我们找到了位置索引，而是要明白**在旧的 <code>children</code> 中找到了与新 <code>children</code> 中第一个节点拥有相同 <code>key</code> 值的节点，意味着什么？**这意味着：<strong>旧 <code>children</code> 中的这个节点所对应的真实 DOM 在新 <code>children</code> 的顺序中，已经变成了第一个节点</strong>。所以我们需要把该节点所对应的真实 DOM 移动到最前头，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-13.b88d7abb.png" alt="img"></p> <p>可以用如下高亮的代码来实现这个过程：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素</span>
    <span class="token keyword">const</span> idxInOld <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>
      <span class="token parameter">node</span> <span class="token operator">=&gt;</span> node<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key
    <span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>idxInOld <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// vnodeToMove 就是在旧 children 中找到的节点，该节点所对应的真实 DOM 应该被移动到最前面</span>
      <span class="token keyword">const</span> vnodeToMove <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span>
      <span class="token comment">// 调用 patch 函数完成更新</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">,</span> newStartVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token comment">// 把 vnodeToMove.el 移动到最前面，即 oldStartVNode.el 的前面</span>
      container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
      <span class="token comment">// 由于旧 children 中该位置的节点所对应的真实 DOM 已经被移动，所以将其设置为 undefined</span>
      prevChildren<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将 newStartIdx 下移一位</span>
    newStartVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>如果 <code>idxInOld</code> 存在，说明我们在旧 <code>children</code> 中找到了相应的节点，于是我们拿到该节点，将其赋值给 <code>vnodeToMove</code> 常量，意味着该节点是需要被移动的节点，同时调用 <code>patch</code> 函数完成更新，接着将该节点所对应的真实 DOM 移动到最前面，也就是 <code>oldStartVNode.el</code> 前面，由于该节点所对应的真实 DOM 已经被移动，所以我们将该节点置为 <code>undefined</code>，这是很关键的异步，最后我们将 <code>newStartIdx</code> 下移一位，准备进行下一轮的比较。我们用一张图来描述这个过程结束之后的状态：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-14.ca021a85.png" alt="img"></p> <p>这里大家需要注意，由上图可知，由于原本旧 <code>children</code> 中的 <code>li-b</code> 节点，此时已经变成了 <code>undefined</code>，所以在后续的比对过程中 <code>oldStartIdx</code> 或 <code>oldEndIdx</code> 二者当中总会有一个位置索引优先达到这个位置，也就是说此时 <code>oldStartVNode</code> 或 <code>oldEndVNode</code> 两者之一可能是 <code>undefined</code>，这说明该位置的元素在之前的比对中被移动到别的位置了，所以不再需要处理该位置的节点，这时我们需要跳过这一位置，所以我们需要增加如下高亮代码来完善我们的算法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldStartVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oldStartVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldEndVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oldEndVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> idxInOld <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>
      <span class="token parameter">node</span> <span class="token operator">=&gt;</span> node<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key
    <span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>idxInOld <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> vnodeToMove <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">,</span> newStartVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      prevChildren<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
      container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    newStartVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>当 <code>oldStartVNode</code> 或 <code>oldEndVNode</code> 不存在时，说明该节点已经被移动了，我们只需要跳过该位置即可。以上就是我们所说的双端比较的非理想情况的处理方式。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/vjp265qxnl</p> <p><a href="https://codesandbox.io/s/vjp265qxnl" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="添加新元素-2"><a href="#添加新元素-2" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0-2" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 添加新元素</h3> <p>在上一小节中，我们尝试拿着新 <code>children</code> 中的第一个节点去旧 <code>children</code> 中寻找与之拥有相同 <code>key</code> 值的可复用节点，然后并非总是能够找得到，当新的 <code>children</code> 中拥有全新的节点时，就会出现找不到的情况，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-15.08ec9ab8.png" alt="img"></p> <p>在新 <code>children</code> 中，节点 <code>li-d</code> 是一个全新的节点。在这个例子中 ①、②、③、④ 这四步的比对仍然无法找到可复用节点，所以我们会尝试拿着新 <code>children</code> 中的 <code>li-d</code> 节点去旧的 <code>children</code> 寻找与之拥有相同 <code>key</code> 值的节点，结果很显然，我们无法找到这样的节点。这时说明该节点是一个全新的节点，我们应该将其挂载到容器中，不过应该将其挂载到哪里呢？稍作分析即可得出结论，由于 <code>li-d</code> 节点的位置索引是 <code>newStartIdx</code>，这说明 <code>li-d</code> 节点是当前这一轮比较中的“第一个”节点，所以只要把它挂载到位于 <code>oldStartIdx</code> 位置的节点所对应的真实 DOM 前面就可以了，即 <code>oldStartVNode.el</code>，我们只需要增加一行代码即可实现该功能：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldStartVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oldStartVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldEndVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oldEndVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> idxInOld <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>
      <span class="token parameter">node</span> <span class="token operator">=&gt;</span> node<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartVNode<span class="token punctuation">.</span>key
    <span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>idxInOld <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> vnodeToMove <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">,</span> newStartVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      prevChildren<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
      container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 使用 mount 函数挂载新节点</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>newStartVNode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    newStartVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>如上高亮代码所示，如果条件 <code>idxInOld &gt;= 0</code> 不成立，则说明 <code>newStartVNode</code> 是一个全新的节点，我们添加了 <code>else</code> 语句块用来处理全新的节点，在 <code>else</code> 语句块内调用 <code>mount</code> 函数挂载该全新的节点，根据上面的分析，我们只需要把该节点挂载到 <code>oldStartVNode.el</code> 之前即可，所以我们传递给 <code>mount</code> 函数的第四个参数就是 <code>oldStartVNode.el</code>。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/n7y46ojv4m</p> <p><a href="https://codesandbox.io/s/n7y46ojv4m" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>但这么做真的就完美了吗？不是的，来看下面这个例子，我们更换新 <code>children</code> 中节点的顺序，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-16.ce5c6d2b.png" alt="img"></p> <p>与之前的案例不同，在之前的案例中新 <code>children</code> 中节点的顺序为 <code>li-d</code>、<code>li-a</code>、<code>li-c</code> 最后是 <code>li-b</code>，我们观察上图可以发现，本例中新 <code>children</code> 的节点顺序为 <code>li-d</code>、<code>li-a</code>、<code>li-b</code> 最后是 <code>li-c</code>，那么顺序的不同会对结果产生影响吗？想弄明白这个问题很简单，我们只需要按照双端比较算法的思路来模拟执行一次即可得出结论：</p> <ul><li>第一步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-d</code> 进行比对，由于二者 <code>key</code> 值不同，所以不可复用，什么都不做。</li> <li>第二步：拿旧 <code>children</code> 中的 <code>li-c</code> 和新 <code>children</code> 中的 <code>li-c</code> 进行比对，此时，二者拥有相同的 <code>key</code> 值。</li></ul> <p>在第二步中找到了可复用节点，接着使用 <code>patch</code> 函数对该节点进行更新，同时将相应的位置索引下移一位，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-17.b4d9f7a4.png" alt="img"></p> <p>接着，开始下一轮的比较，重新从第一步开始。结果和上一轮相似，同样在第二步中找到可复用的节点，所以在在这一轮的更新完成之后，其状态如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-18.cc8a1fae.png" alt="img"></p> <p>由上图可知，此时的 <code>oldStartIdx</code> 与 <code>oldEndIdx</code> 已经重合，它们的值都是 <code>0</code>，但是此时仍然满足循环条件，所以比对不会停止，会继续下一轮的比较。在新的一轮比较中，仍然会在第二步找到可复用的节点，所以在这一轮更新完成之后 <code>oldEndIdx</code> 将比 <code>oldStartIdx</code> 的值要小，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-19.1d4087f6.png" alt="img"></p> <p>此时 <code>oldEndIdx</code> 的值将变成 <code>-1</code>，它要小于 <code>oldStartIdx</code> 的值，这时循环的条件不在满足，意味着更新完成。然而通过上图可以很容易的发现 <code>li-d</code> 节点被遗漏了，它没有得到任何的处理，通过这个案例我们意识到了之前的算法是存在缺陷的，为了弥补这个缺陷，我们需要在循环终止之后，对 <code>oldEndIdx</code> 和 <code>oldStartIdx</code> 的值进行检查，如果在循环结束之后 <code>oldEndIdx</code> 的值小于 <code>oldStartIdx</code> 的值则说明新的 <code>children</code> 中存在<strong>还没有被处理的全新节点</strong>，这时我们应该调用 <code>mount</code> 函数将其挂载到容器元素中，观察上图可知，我们只需要把这些全新的节点添加到 <code>oldStartIdx</code> 索引所指向的节点之前即可，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndIdx <span class="token operator">&lt;</span> oldStartIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 添加新节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> newStartIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>我们在循环结束之后，立即判断 <code>oldEndIdx</code> 的值是否小于 <code>oldStartIdx</code> 的值，如果条件成立，则需要使用 <code>for</code> 循环把所有位于 <code>newStartIdx</code> 到 <code>newEndIdx</code> 之间的元素都当做全新的节点添加到容器元素中，这样我们就完整的实现了完整的添加新节点的功能。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/ryryx6n42m</p> <p><a href="https://codesandbox.io/s/ryryx6n42m" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="移除不存在的元素-2"><a href="#移除不存在的元素-2" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%83%E7%B4%A0-2" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 移除不存在的元素</h3> <p>对于双端比较，最后一个需要考虑的情况是：当有元素被移除时的情况，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-20.a80cbba0.png" alt="img"></p> <p>观察上图可以发现，在新 <code>children</code> 中 <code>li-b</code> 节点已经不存在了，所以完整的更新过程应该包含：<strong>移除已不存在节点所对应真实 DOM 的功能</strong>。为了找到哪些节点需要移除，我们首先还是按照双端比较的算法步骤模拟执行一下即可：</p> <ul><li>第一步：拿旧 <code>children</code> 中的 <code>li-a</code> 和新 <code>children</code> 中的 <code>li-a</code> 进行比对，此时，二者拥有相同的 <code>key</code> 值。</li></ul> <p>在第一轮的第一步比对中，我们就找到了可复用节点，所以此时会调用 <code>patch</code> 函数更新该节点，并更新相应的索引值，可以用下图表示这一轮更新完成之后算法所处的状态：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-21.f4b83431.png" alt="img"></p> <p>这时 <code>newStartIdx</code> 和 <code>newEndIdx</code> 的值相等，都是 <code>1</code>，不过循环的条件仍然满足，所以会立即进行下一轮比较：</p> <ul><li>第一步：拿旧 <code>children</code> 中的 <code>li-b</code> 和新 <code>children</code> 中的 <code>li-c</code> 进行比对，由于二者 <code>key</code> 值不同，所以不可复用，什么都不做。</li> <li>第二步：拿旧 <code>children</code> 中的 <code>li-c</code> 和新 <code>children</code> 中的 <code>li-c</code> 进行比对，此时，二者拥有相同的 <code>key</code> 值。</li></ul> <p>在第二步的比对中找到了可复用节点 <code>li-c</code>，接着更新该节点，并将 <code>oldEndIdx</code> 和 <code>newEndIdx</code> 分别前移一位，最终结果如下：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff-vue2-22.cb427ed4.png" alt="img"></p> <p>由于此时 <code>newEndIdx</code> 的值小于 <code>newStartIdx</code> 的值，所以循环将终止，但是通过上图可以发现，旧 <code>children</code> 中的 <code>li-b</code> 节点没有得到被处理的机会，我们应该将其移除才行，然后本次循环结束之后并不满足条件 <code>oldEndIdx &lt; oldStartIdx</code> 而是满足条件 <code>newEndIdx &lt; newStartIdx</code>，基于此，我们可以认为<strong>循环结束后，一旦满足条件 <code>newEndIdx &lt; newStartId</code> 则说明有元素需要被移除</strong>。我们增加如下代码来实现该功能：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndIdx <span class="token operator">&lt;</span> oldStartIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 添加新节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> newStartIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> oldStartVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newEndIdx <span class="token operator">&lt;</span> newStartIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 移除操作</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldStartIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> oldEndIdx<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>如上高亮代码所示，增加 <code>else...if</code> 语句块，用来处理当 <code>newEndIdx &lt; newStartIdx</code> 时的情况，我们同样开启一个 <code>for</code> 循环，把所有位于 <code>oldStartIdx</code> 和 <code>oldEndIdx</code> 之间的节点所对应的真实 DOM 全部移除即可。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/9jnvjj1mko</p> <p><a href="https://codesandbox.io/s/9jnvjj1mko" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>以上就是相对完整的双端比较算法的实现，这是  所采用的算法，借鉴于开源项目：<a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a href="https://github.com/joelrich/citojs" target="_blank" rel="noopener noreferrer">citojs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>。</p> <h2 id="inferno-所采用的核心-diff-算法及原理"><a href="#inferno-所采用的核心-diff-算法及原理" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#inferno-%E6%89%80%E9%87%87%E7%94%A8%E7%9A%84%E6%A0%B8%E5%BF%83-diff-%E7%AE%97%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> inferno 所采用的核心 Diff 算法及原理</h2> <p>在 <code>Vue3</code> 中将采用另外一种核心 <code>Diff</code> 算法，它借鉴于 <a href="https://github.com/localvoid/ivi" target="_blank" rel="noopener noreferrer">ivi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://github.com/localvoid/ivi" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a href="https://github.com/infernojs/inferno" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><img src="http://hcysun.me/vue-design/assets/img/diff-benchmark.6d4927ac.png" alt="img"></p> <p>这张图来自 <a href="https://krausest.github.io/js-framework-benchmark/current.html" target="_blank" rel="noopener noreferrer">js-framework-benchmark<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://krausest.github.io/js-framework-benchmark/current.html" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>，从上图中可以看到，在 DOM 操作的各个方面，<code>ivi</code> 和 <code>inferno</code> 都要稍优于 <code>vue2</code> 的双端比较。但总体上的性能表现并不是单纯的由核心 <code>Diff</code> 算法来决定的，我们在前面章节的讲解中已经了解到的了一些优化手段，例如<strong>在创建 <code>VNode</code> 时就确定其类型，以及在 <code>mount/patch</code> 的过程中采用位运算来判断一个 <code>VNode</code> 的类型</strong>，在这个基础之上再配合核心的 <code>Diff</code> 算法，才使得性能上产生一定的优势，这也是 <code>Vue3</code> 接纳这种算法的原因之一，本节我们就着重讨论该核心 <code>Diff</code> 算法的实现原理。</p> <h3 id="相同的前置和后置元素"><a href="#相同的前置和后置元素" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E7%9B%B8%E5%90%8C%E7%9A%84%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E5%85%83%E7%B4%A0" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 相同的前置和后置元素</h3> <p>实际上本节介绍的 <code>Diff</code> 算法最早应用于两个不同文本之间的差异比较，在文本 <code>Diff</code> 中，真正进行核心的 <code>Diff</code> 算法之前，会有一个预处理的过程，例如可以先对两个文本进行“相等”比较：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>text1 <span class="token operator">===</span> text2<span class="token punctuation">)</span> <span class="token keyword">return</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果两个文本相等，则无需进行真正的 <code>Diff</code>，预处理的好处之一就是<strong>在某些情况下能够避免 <code>Diff</code> 算法的执行</strong>，还有比这更加高效的方式吗？当然，这是一个简单的情形，除此之外，在文本的 <code>Diff</code> 中还有其他的预处理过程，其中就包含：去除<strong>相同的前缀和后缀</strong>。什么意思呢？假设我们有如下两个文本：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>TEXT1: I use vue for app development
text2: I use react for app development
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>我们通过肉眼可以很容易的发现，这两段文本头部和尾部分别有一段相同的文本：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff1.7cd0d7d1.png" alt="img"></p> <p>所以真正需要进行 <code>Diff</code> 的部分就变成了：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>text1: vue
text2: react
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这么做的好处是：在某些情况下，我们能够轻松的判断出单独的文本插入和删除，例如下面的例子：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>text1: I like you
text2: I like you too
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这两个文本在经过去除相同的前缀和后缀之后将变成：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>text1:
text2: too
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>所以当预处理结束之后，如果 <code>text1</code> 为空且 <code>text2</code> 不为空，则可以认为这是一个文本插入，相反的，如果将这两个文本互换位置就是一个文本删除的案例：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>text1: I like you too
text2: I like you
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>则经过预处理之后将变成：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>text1: too
text2:
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这代表文本被删除。</p> <p>很显然，该预处理过程在上例的情况下能够避免 <code>Diff</code> 算法的执行，从而提高 <code>Diff</code> 效率。当然，换一个角度来看的话，这本身也是 <code>Diff</code> 策略的一部分，不过这显然要更高效。所以我们能否将此预处理步骤应用到 <code>VNode</code> 的 <code>Diff</code> 中呢？当然可以，来看下面的例子：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff2.469b3f9b.png" alt="img"></p> <p>如上图所示，新旧 <code>children</code> 拥有相同的前缀节点和后缀节点，对于前缀节点，我们可以建立一个索引，指向新旧 <code>children</code> 中的第一个节点，并逐步向后遍历，直到遇到两个拥有不同 <code>key</code> 值的节点为止，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 更新相同的前缀节点</span>
<span class="token comment">// j 为指向新旧 children 中第一个节点的索引</span>
<span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">let</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
<span class="token keyword">let</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
<span class="token comment">// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用 patch 函数更新</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  j<span class="token operator">++</span>
  prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
  nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以用下图描述这一步操作完成之后的状态：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff3.58e3c241.png" alt="img"></p> <p>这里大家需要注意的是，当 <code>while</code> 循环终止时，索引 <code>j</code> 的值为 <code>1</code>。接着，我们需要处理的是相同的后缀节点，由于新旧 <code>children</code> 中节点的数量可能不同，所以我们需要两个索引分别指向新旧 <code>children</code> 的最后一个节点，并逐步向前遍历，直到遇到两个拥有不同 <code>key</code> 值的节点为止，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 更新相同的后缀节点</span>

<span class="token comment">// 指向旧 children 最后一个节点的索引</span>
<span class="token keyword">let</span> prevEnd <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
<span class="token comment">// 指向新 children 最后一个节点的索引</span>
<span class="token keyword">let</span> nextEnd <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>

prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>prevEnd<span class="token punctuation">]</span>
nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>nextEnd<span class="token punctuation">]</span>

<span class="token comment">// while 循环向前遍历，直到遇到拥有不同 key 值的节点为止</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用 patch 函数更新</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  prevEnd<span class="token operator">--</span>
  nextEnd<span class="token operator">--</span>
  prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>prevEnd<span class="token punctuation">]</span>
  nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>nextEnd<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>可以用下图来表示这一步更新完成之后的状态：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff4.b6517d9f.png" alt="img"></p> <p>同样需要注意的是，在这一步更新完成之后 <code>prevEnd</code> 的值为 <code>0</code>，<code>nextEnd</code> 的值为 <code>1</code>。实际上三个索引 <code>j</code>、<code>prevEnd</code> 和 <code>nextEnd</code> 的值至关重要，它们之间的大小关系反映了新旧 <code>children</code> 的节点状况。前面我们在讲解文本 <code>Diff</code> 的时候曾说过，当“去掉”相同的前缀和后缀之后，如果旧文本为空，且新文本不为空，则说明有新的文本内容被添加，反之则说明有旧的文本被移除。现在三个索引的值如下：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>j: 1
prevEnd: 0
nextEnd: 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们发现 <code>j &gt; prevEnd</code> 并且 <code>j &lt;= nextEnd</code>，这说明当新旧 <code>children</code> 中相同的前缀和后缀被更新之后，旧 <code>children</code> 中的节点已经被更新完毕了，而新 <code>children</code> 中仍然有剩余节点，通过上图可以发现，新 <code>children</code> 中的 <code>li-d</code> 节点，就是这个剩余的节点。实际上新 <code>children</code> 中位于 <code>j</code> 到 <code>nextEnd</code> 之间的所有节点都应该是新插入的节点：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff5.edd80c32.png" alt="img"></p> <p>那么应该将这些新的节点插入到什么位置呢？观察上图，从新 <code>children</code> 中的节点顺序可以发现，新的节点都出现在 <code>li-b</code> 节点的前面，所以我们可以使用一个循环遍历索引 <code>j -&gt; nextEnd</code> 之间的节点，并逐个将其插入到 <code>li-b</code> 节点之前，这样当循环结束之后，新的节点就被插入到了正确的位置。我们还能发现 <code>li-b</code> 节点的位置可以用 <code>nextEnd + 1</code> 表示，最终我们可以使用如下代码来实现节点的插入：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 满足条件，则说明从 j -&gt; nextEnd 之间的节点应作为新节点插入</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 所有新节点应该插入到位于 nextPos 位置的节点的前面</span>
  <span class="token keyword">const</span> nextPos <span class="token operator">=</span> nextEnd <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token keyword">const</span> refNode <span class="token operator">=</span>
    nextPos <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">?</span> nextChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el <span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token comment">// 采用 while 循环，调用 mount 函数挂载节点</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>再来看如下案例：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff6.a882df3d.png" alt="img"></p> <p>在这个案例中，当“去掉”相同的前缀和后缀之后，三个索引的值为：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>j: 1
prevEnd: 1
nextEnd: 0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这时条件 <code>j &gt; nextEnd</code> 并且 <code>j &lt;= prevEnd</code> 成立，通过上图可以很容的发现，旧 <code>children</code> 中的 <code>li-b</code> 节点应该被移除，实际上更加通用的规则应该是：在旧 <code>children</code> 中有位于索引 <code>j</code> 到 <code>prevEnd</code> 之间的节点，都应该被移除。如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff7.df9450ee.png" alt="img"></p> <p>代码实现起来也很简单，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// j -&gt; nextEnd 之间的节点应该被添加</span>
  <span class="token keyword">const</span> nextPos <span class="token operator">=</span> nextEnd <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token keyword">const</span> refNode <span class="token operator">=</span>
    nextPos <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">?</span> nextChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el <span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// j -&gt; prevEnd 之间的节点应该被移除</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>现在我们来观察一下总体的代码结构：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用 patch 函数更新</span>
  <span class="token comment">// 省略...</span>
  j<span class="token operator">++</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>

<span class="token comment">// while 循环向前遍历，直到遇到拥有不同 key 值的节点为止</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用 patch 函数更新</span>
  <span class="token comment">// 省略...</span>
  prevEnd<span class="token operator">--</span>
  nextEnd<span class="token operator">--</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 满足条件，则说明从 j -&gt; nextEnd 之间的节点应作为新节点插入</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// j -&gt; nextEnd 之间的节点应该被添加</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// j -&gt; prevEnd 之间的节点应该被移除</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>观察如上高亮的代码，我们发现，在两个 <code>while</code> 循环中，索引 <code>j</code> 和 索引 <code>prevEnd</code>、<code>nextEnd</code> 是以“从两端向中间靠拢”的趋势在变化的，而在两个 <code>while</code> 循环结束之后，我们会根据这三个索引的大小关系来决定应该做什么样的操作。现在我们思考一个问题，假设在第一个 <code>while</code> 循环结束之后，索引 <code>j</code> 的值已经大于 <code>prevEnd</code> 或 <code>nextEnd</code>，那么还有必须执行第二个 <code>while</code> 循环吗？答案是没有必要，这是因为一旦索引 <code>j</code> 大于 <code>prevEnd</code> 则说明旧 <code>children</code> 中的所有节点都已经参与了 <code>patch</code>，类似的，如果索引 <code>j</code> 大于 <code>nextEnd</code> 则说明新 <code>children</code> 中的所有节点都已经参与了 <code>patch</code>，这时当然没有必要再执行后续的操作了。所以出于性能的考虑，我们应该避免没有必要的代码执行，为了达到目的，可以使用 <code>javascript</code> 中的 <code>label</code> 语句，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>outer<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    j<span class="token operator">++</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">||</span> j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span> outer
    <span class="token punctuation">}</span>
    prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 更新相同的后缀节点</span>
  prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>prevEnd<span class="token punctuation">]</span>
  nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>nextEnd<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    prevEnd<span class="token operator">--</span>
    nextEnd<span class="token operator">--</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">||</span> j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span> outer
    <span class="token punctuation">}</span>
    prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>prevEnd<span class="token punctuation">]</span>
    nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>nextEnd<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>我们定义了 <code>label</code> 名字为 <code>outer</code> 的 <code>label</code> 语句块，并分别在两个 <code>while</code> 循环中添加了判断语句，无论在哪个循环中，只要索引 <code>j</code> 的值大于了 <code>prevEnd</code> 或 <code>nextEnd</code> 二者之一，我们就 <code>break</code> 该语句块，从而避免了无用的代码执行。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/5yo3z824vp</p> <p><a href="https://codesandbox.io/s/5yo3z824vp" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="判断是否需要进行-dom-移动"><a href="#判断是否需要进行-dom-移动" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C-dom-%E7%A7%BB%E5%8A%A8" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 判断是否需要进行 DOM 移动</h3> <p>刚刚我们讲解了一个很重要的预处理思路：“去掉”相同的前置/后置节点。并且我们分析了在一些情况下这种预处理操作能够避免真正 <code>Diff</code> 算法的执行：通过判断索引的大小关系，能够提前知道哪些元素被添加，哪些元素被移除。但这毕竟属于一种特殊情况，大部分情况下可能未必如此理想，来看如下案例：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff8.f618edee.png" alt="img"></p> <p>观察上图中新旧 <code>children</code> 中节点的顺序，我们发现，这个案例在应用预处理步骤之后，只有 <code>li-a</code> 节点和 <code>li-e</code> 节点能够被提前 <code>patch</code>。换句话说在这种情况下没有办法简单的通过预处理就能够结束 <code>Diff</code> 逻辑。这时我们就需要进行下一步操作，实际上无论是 <code>React</code> 的 <code>Diff</code> 算法，还是 <code>Vue2(snabbdom)</code> 的 <code>Diff</code> 算法，其重点无非就是：<strong>判断是否有节点需要移动，以及应该如何移动</strong>和<strong>寻找出那些需要被添加或移除</strong>的节点，而本节我们所讲解的算法也不例外，所以接下来的任务就是：判断那些节点需要移动，以及如何移动。</p> <p>为了让事情更直观我们把该案例在应用预处理之后的状态用下图描述出来：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff9.c4746f37.png" alt="img"></p> <p>观察上图可以发现，此时索引 <code>j</code> 既不大于 <code>prevEnd</code> 也不大于 <code>nextEnd</code>，所以如下代码将得不到执行：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 满足条件，则说明从 j -&gt; nextEnd 之间的节点应作为新节点插入</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// j -&gt; nextEnd 之间的节点应该被添加</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// j -&gt; prevEnd 之间的节点应该被移除</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>我们需要为这段代码添加 <code>else</code> 语句块，用来处理该案例的情况，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 满足条件，则说明从 j -&gt; nextEnd 之间的节点应作为新节点插入</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// j -&gt; nextEnd 之间的节点应该被添加</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// j -&gt; prevEnd 之间的节点应该被移除</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在这里编写处理逻辑</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>知道了应该在哪里编写处理逻辑，那么接下来我们就讲解一下该算法的思路。首先，我们需要构造一个数组 <code>source</code>，该数组的长度等于新 <code>children</code> 在经过预处理之后剩余未处理节点的数量，并且该数组中每个元素的初始值为 <code>-1</code>，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff10.f2a5a3e6.png" alt="img"></p> <p>我们可以通过如下代码完成 <code>source</code> 数组的构造：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 构造 source 数组</span>
  <span class="token keyword">const</span> nextLeft <span class="token operator">=</span> nextEnd <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment">// 新 children 中剩余未处理节点的数量</span>
  <span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextLeft<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    source<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>那么这个数组的作用是什么呢？通过上图可以发现，该数组中的每一个元素分别与新 <code>children</code> 中剩余未处理的节点对应，实际上 <code>source</code> 数组将用来存储<strong>新 <code>children</code> 中的节点在旧 <code>children</code> 中的位置，后面将会使用它计算出一个最长递增子序列，并用于 DOM 移动</strong>。如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff11.48afbeb3.png" alt="img"></p> <p>我们可以通过两层 <code>for</code> 循环来完成这个工作，外层循环用于遍历旧 <code>children</code>，内层循环用于遍历新 <code>children</code>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> prevStart <span class="token operator">=</span> j
<span class="token keyword">const</span> nextStart <span class="token operator">=</span> j
<span class="token comment">// 遍历旧 children</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> prevStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token comment">// 遍历新 children</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> nextStart<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
    <span class="token comment">// 找到拥有相同 key 值的可复用节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// patch 更新</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token comment">// 更新 source 数组</span>
      source<span class="token punctuation">[</span>k <span class="token operator">-</span> nextStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>如上代码所示，外层循环逐个从旧 <code>children</code> 中取出未处理的节点，并尝试在新 <code>children</code> 中寻找拥有相同 <code>key</code> 值的可复用节点，一旦找到了可复用节点，则调用 <code>patch</code> 函数更新之。接着更新 <code>source</code> 数组中对应位置的值，这里需要注意的是，由于 <code>k - nextStart</code> 的值才是正确的位置索引，而非 <code>k</code> 本身，并且外层循环中变量 <code>i</code> 的值就代表了该节点在旧 <code>children</code> 中的位置，所以直接将 <code>i</code> 赋值给 <code>source[k - nextStart]</code> 即可达到目的，最终的效果就如上图中所展示的那样。可以看到 <code>source</code> 数组的第四个元素值仍然为初始值 <code>-1</code>，这是因为<strong>新 <code>children</code> 中的 <code>li-g</code> 节点不存在于旧 <code>children</code> 中</strong>。除此之外，还有一件很重要的事儿需要做，即判断是否需要移动节点，判断的方式类似于 <code>React</code> 所采用的方式，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> prevStart <span class="token operator">=</span> j
<span class="token keyword">const</span> nextStart <span class="token operator">=</span> j
<span class="token keyword">let</span> moved <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">let</span> pos <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> prevStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> nextStart<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// patch 更新</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token comment">// 更新 source 数组</span>
      source<span class="token punctuation">[</span>k <span class="token operator">-</span> nextStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
      <span class="token comment">// 判断是否需要移动</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        moved <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        pos <span class="token operator">=</span> k
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>变量 <code>k</code> 代表我们在遍历新 <code>children</code> 中遇到的节点的位置索引，变量 <code>pos</code> 用来存储遇到的位置索引的最大值，一旦发现后来遇到索引比之前遇到的索引要小，即 <code>k &lt; pos</code>，则说明需要移动操作，这时我们更新变量 <code>moved</code> 的值为 <code>true</code>，<code>moved</code> 变量将会在后面使用。</p> <p>不过在进一步讲解之前，我们需要回头思考一下上面的代码存在怎样的问题？上面的代码中我们采用两层嵌套的循环，其时间复杂度为 <code>O(n1 * n2)</code>，其中 <code>n1</code> 和 <code>n2</code> 为新旧 <code>children</code> 中节点的数量，我们也可以使用 <code>O(n^2)</code> 来表示，当新旧 <code>children</code> 中节点的数量较多时，则两层嵌套的循环会带来性能的问题，出于优化的目的，我们可以为新的 <code>children</code> 中的节点构建一个 <code>key</code> 到 <code>位置索引</code> 的<strong>索引表</strong>，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff12.566f24a9.png" alt="img"></p> <p><code>Index Map</code> 中的键是节点的 <code>key</code>，值是节点在新 <code>children</code> 中的位置索引，由于数据结构带来的优势，使得我们能够非常快速的定位旧 <code>children</code> 中的节点在新 <code>children</code> 中的位置，落实的代码如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> prevStart <span class="token operator">=</span> j
<span class="token keyword">const</span> nextStart <span class="token operator">=</span> j
<span class="token keyword">let</span> moved <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">let</span> pos <span class="token operator">=</span> <span class="token number">0</span>
<span class="token comment">// 构建索引表</span>
<span class="token keyword">const</span> keyIndex <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  keyIndex<span class="token punctuation">[</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
<span class="token punctuation">}</span>
<span class="token comment">// 遍历旧 children 的剩余未处理节点</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> prevStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token comment">// 通过索引表快速找到新 children 中具有相同 key 的节点的位置</span>
  <span class="token keyword">const</span> k <span class="token operator">=</span> keyIndex<span class="token punctuation">[</span>prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
    <span class="token comment">// patch 更新</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token comment">// 更新 source 数组</span>
    source<span class="token punctuation">[</span>k <span class="token operator">-</span> nextStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
    <span class="token comment">// 判断是否需要移动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      moved <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      pos <span class="token operator">=</span> k
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 没找到</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>这是典型的<strong>用空间换时间</strong>的方式，复杂度能够降低到 <code>O(n)</code>。但无论采用哪一种方式，最终我们的目的是<strong>对新旧 <code>children</code> 中具有相同 <code>key</code> 值的节点进行更新，同时检测是否需要移动操作</strong>。在如上代码执行完毕之后，如果发现变量 <code>moved</code> 的值为 <code>true</code>，则说明需要移动操作。</p> <p>另外在上面的代码中，我们试图拿旧 <code>children</code> 中的节点尝试去新 <code>children</code> 中寻找具有相同 <code>key</code> 值的节点，但并非总是能够找得到，当 <code>k === 'undefined'</code> 时，说明该节点在新 <code>children</code> 中已经不存在了，这时我们应该将其移除，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 遍历旧 children 的剩余未处理节点</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> prevStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token comment">// 通过索引表快速找到新 children 中具有相同 key 的节点的位置</span>
  <span class="token keyword">const</span> k <span class="token operator">=</span> keyIndex<span class="token punctuation">[</span>prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 没找到，说明旧节点在新 children 中已经不存在了，应该移除</span>
    container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>除此之外，我们还需要一个数量标识，用来代表<strong>已经更新过的节点的数量</strong>。我们知道，<strong>已经更新过的节点数量</strong>应该小于新 <code>children</code> 中需要更新的节点数量，一旦更新过的节点数量超过了新 <code>children</code> 中需要更新的节点数量，则说明该节点是多余的节点，我们也应该将其移除，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> patched <span class="token operator">=</span> <span class="token number">0</span>
<span class="token comment">// 遍历旧 children 的剩余未处理节点</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> prevStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  prevVNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>patched <span class="token operator">&lt;</span> nextLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过索引表快速找到新 children 中具有相同 key 的节点的位置</span>
    <span class="token keyword">const</span> k <span class="token operator">=</span> keyIndex<span class="token punctuation">[</span>prevVNode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
      <span class="token comment">// patch 更新</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      patched<span class="token operator">++</span>
      <span class="token comment">// 更新 source 数组</span>
      source<span class="token punctuation">[</span>k <span class="token operator">-</span> nextStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
      <span class="token comment">// 判断是否需要移动</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        moved <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        pos <span class="token operator">=</span> k
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 没找到，说明旧节点在新 children 中已经不存在了，应该移除</span>
      container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 多余的节点，应该移除</span>
    container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>变量 <code>patched</code> 将作为数量标识，它的初始值为 <code>0</code>，只有当条件 <code>patched &lt; nextLeft</code> 不成立时，说明该节点已经不存在与新 <code>children</code> 中了，是一个多余的节点，于是我们将其移除。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/03o5plkv40</p> <p><a href="https://codesandbox.io/s/03o5plkv40" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="dom-移动的方式"><a href="#dom-移动的方式" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#dom-%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> DOM 移动的方式</h3> <p>在上一小节，我们的主要目的有两个：1、判断出是否需要进行 DOM 移动操作，所以我们建立了 <code>moved</code> 变量作为标识，当它的值为 <code>true</code> 时则说明需要进行 DOM 移动；2、构建 <code>source</code> 数组，它的长度与“去掉”相同的前置/后置节点后新 <code>children</code> 中剩余未处理节点的数量相等，并存储着新 <code>children</code> 中的节点在旧 <code>children</code> 中位置，后面我们会根据 <code>source</code> 数组计算出一个最长递增子序列，并用于 DOM 移动操作。如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff12.566f24a9.png" alt="img"></p> <p>现在我们已经可以通过判断变量 <code>moved</code> 的值来确定是否需要进行 DOM 移动操作：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果 moved 为真，则需要进行 DOM 移动操作</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>一旦需要进行 DOM 节点的移动，我们首先要做的就是根据 <code>source</code> 数组计算一个最长递增子序列：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 计算最长递增子序列</span>
  <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span> <span class="token comment">// [ 0, 1 ]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>TIP</p> <p>什么是最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。</p> <p>例如给定数值序列为：[ 0, 8, 4, 12 ]</p> <p>那么它的最长递增子序列就是：[0, 8, 12]</p> <p>当然答案可能有多种情况，例如：[0, 4, 12] 也是可以的</p> <p>TIP</p> <p>我们会在下一小节讲解 <code>lis</code> 函数的实现。</p> <p>上面的代码中，我们调用 <code>lis</code> 函数求出数组 <code>source</code> 的最长递增子序列为 <code>[ 0, 1 ]</code>。我们知道 <code>source</code> 数组的值为 <code>[2, 3, 1, -1]</code>，很显然最长递增子序列应该是 <code>[ 2, 3 ]</code>，但为什么计算出的结果是 <code>[ 0, 1 ]</code> 呢？其实 <code>[ 0, 1 ]</code> 代表的是最长递增子序列中的各个元素在 <code>source</code> 数组中的位置索引，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff14.7c7a1bfc.png" alt="img"></p> <p>我们对新 <code>children</code> 中的剩余未处理节点进行了重新编号，<code>li-c</code> 节点的位置是 <code>0</code>，以此类推。而最长递增子序列是 <code>[ 0, 1 ]</code> 这告诉我们：<strong>新 <code>children</code> 的剩余未处理节点中，位于位置 <code>0</code> 和位置 <code>1</code> 的节点的先后关系与他们在旧 <code>children</code> 中的先后关系相同</strong>。或者我们可以理解为<strong>位于位置 <code>0</code> 和位置 <code>1</code> 的节点是不需要被移动的节点</strong>，即上图中 <code>li-c</code> 节点和 <code>li-d</code> 节点将在接下来的操作中不会被移动。换句话说只有 <code>li-b</code> 节点和 <code>li-g</code> 节点是可能被移动的节点，但是我们发现与 <code>li-g</code> 节点位置对应的 <code>source</code> 数组元素的值为 <code>-1</code>，这说明 <code>li-g</code> 节点应该作为全新的节点被挂载，所以只有 <code>li-b</code> 节点需要被移动。我们来看下图：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff15.087a1726.png" alt="img"></p> <p>使用两个索引 <code>i</code> 和 <code>j</code> 分别指向新 <code>children</code> 中剩余未处理节点的最后一个节点和最长递增子序列数组中的最后一个位置，并从后向前遍历，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token comment">// j 指向最长递增子序列的最后一个值</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token comment">// 从后向前遍历新 children 中的剩余未处理节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextLeft <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!==</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 说明该节点需要移动</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当 i === seq[j] 时，说明该位置的节点不需要移动</span>
      <span class="token comment">// 并让 j 指向下一个位置</span>
      j<span class="token operator">--</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>变量 <code>j</code> 指向最长递增子序列的最后一个位置，使用 <code>for</code> 循环从后向前遍历新 <code>children</code> 中剩余未处理的子节点，这里的技巧在于 <code>i</code> 的值的范围是 <code>0</code> 到 <code>nextLeft - 1</code>，这实际上就等价于我们对剩余节点进行了重新编号。接着判断当前节点的位置索引值 <code>i</code> 是否与子序列中位于 <code>j</code> 位置的值相等，如果不相等，则说明该节点需要被移动；如果相等则说明该节点不需要被移动，并且会让 <code>j</code> 指向下一个位置。但是我们观察上图可以发现 <code>li-g</code> 节点的位置索引是 <code>3</code>，它不等于 <code>1</code>(<code>seq[j]</code>)，难道说明 <code>li-g</code> 节点需要被移动吗？其实不是，我们还可以发现与 <code>li-g</code> 节点位置对应的 <code>source</code> 数组中的元素值为 <code>-1</code>，这说明 <code>li-g</code> 节点应该作为全新的节点挂载，所以我们还需增加一个判断，优先检查一个节点是否是全新的节点：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token comment">// j 指向最长递增子序列的最后一个值</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token comment">// 从后向前遍历新 children 中的剩余未处理节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextLeft <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 作为全新的节点挂载</span>

      <span class="token comment">// 该节点在新 children 中的真实位置索引</span>
      <span class="token keyword">const</span> pos <span class="token operator">=</span> i <span class="token operator">+</span> nextStart
      <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>pos<span class="token punctuation">]</span>
      <span class="token comment">// 该节点下一个节点的位置索引</span>
      <span class="token keyword">const</span> nextPos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token comment">// 挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>
        nextVNode<span class="token punctuation">,</span>
        container<span class="token punctuation">,</span>
        <span class="token boolean">false</span><span class="token punctuation">,</span>
        nextPos <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length
          <span class="token operator">?</span> nextChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el
          <span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!==</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 说明该节点需要移动</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当 i === seq[j] 时，说明该位置的节点不需要移动</span>
      <span class="token comment">// 并让 j 指向下一个位置</span>
      j<span class="token operator">--</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>如上代码的关键在于，为了将节点挂载到正确的位置，我们需要找到当前节点的真实位置索引(<code>i + nextStart</code>)，以及当前节点的后一个节点，并挂载该节点的前面即可。这样我们就完成了 <code>li-g</code> 节点的挂载。接着循环会继续执行，索引 <code>i</code> 将指向下一个位置，即指向 <code>li-b</code> 节点，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff16.3bb06229.png" alt="img"></p> <p><code>li-b</code> 节点的位置索引 <code>i</code> 的值为 <code>2</code>，由于 <code>source[2]</code> 的值为 <code>1</code>，不等于 <code>-1</code>，说明 <code>li-b</code> 节点不是全新的节点。接着会判断 <code>i !== seq[j]</code>，很显然 <code>2 !== 1</code>，这说明 <code>li-b</code> 节点是需要被移动的节点，那么应该如何移动呢？很简单，找到 <code>li-b</code> 节点的后一个节点(<code>li-g</code>)，将其插入到 <code>li-g</code> 节点的前面即可，由于 <code>li-g</code> 节点已经被挂载，所以我们能够拿到它对应的真实 DOM，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token comment">// j 指向最长递增子序列的最后一个值</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token comment">// 从后向前遍历新 children 中的剩余未处理节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextLeft <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 作为全新的节点挂载</span>

      <span class="token comment">// 该节点在新 children 中的真实位置索引</span>
      <span class="token keyword">const</span> pos <span class="token operator">=</span> i <span class="token operator">+</span> nextStart
      <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>pos<span class="token punctuation">]</span>
      <span class="token comment">// 该节点下一个节点的位置索引</span>
      <span class="token keyword">const</span> nextPos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token comment">// 挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>
        nextVNode<span class="token punctuation">,</span>
        container<span class="token punctuation">,</span>
        <span class="token boolean">false</span><span class="token punctuation">,</span>
        nextPos <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length
          <span class="token operator">?</span> nextChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el
          <span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!==</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 说明该节点需要移动</span>

      <span class="token comment">// 该节点在新 children 中的真实位置索引</span>
      <span class="token keyword">const</span> pos <span class="token operator">=</span> i <span class="token operator">+</span> nextStart
      <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>pos<span class="token punctuation">]</span>
      <span class="token comment">// 该节点下一个节点的位置索引</span>
      <span class="token keyword">const</span> nextPos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token comment">// 移动</span>
      container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>
        nextVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span>
        nextPos <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length
          <span class="token operator">?</span> nextChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el
          <span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当 i === seq[j] 时，说明该位置的节点不需要移动</span>
      <span class="token comment">// 并让 j 指向下一个位置</span>
      j<span class="token operator">--</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>到了这里 <code>li-b</code> 节点已经被我们移动到了正确的位置，接着会进行下一次循环，如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff17.21e18aa5.png" alt="img"></p> <p>此时索引 <code>j</code> 依然指向子序列的最后一个位置，索引 <code>i</code> 的值为 <code>1</code>，它指向 <code>li-d</code> 节点。同样的，由于 <code>source[1]</code> 的值为 <code>3</code> 不等于 <code>-1</code>，说明 <code>li-d</code> 节点也不是全新的节点。接着判断 <code>li-d</code> 节点的位置索引 <code>i</code> 的值与子序列 <code>seq[j]</code> 的值相等，都为 <code>1</code>，这说明 <code>li-d</code> 节点不需要被移动，此时会把索引 <code>j</code> 指向下一个位置，结束本次循环并开启下一次循环，下一次循环时的状态如下图所示：</p> <p><img src="http://hcysun.me/vue-design/assets/img/diff18.6f45cb0f.png" alt="img"></p> <p><code>li-c</code> 节点既不是新节点，也不需要被移动，至此循环结束，更新完成。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/4lrqpv0jm9</p> <p><a href="https://codesandbox.io/s/4lrqpv0jm9" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="求解最长递增子序列"><a href="#求解最长递增子序列" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E6%B1%82%E8%A7%A3%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 求解最长递增子序列</h3> <p>上一小节我们已经介绍了什么是最长递增子序列，同时我们使用 <code>lis</code> 函数求解一个给定序列的最长递增子序列，本节我们就来探索一下如何求出给定序列的最长递增子序列。</p> <p>设给定的序列如下：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>[ 0, 8, 4, 12, 2, 10 ]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>实际上，这是一个可以利用动态规划思想求解的问题。动态规划的思想是将一个大的问题分解成多个小的子问题，并尝试得到这些子问题的最优解，子问题的最优解有可能会在更大的问题中被利用，这样通过小问题的最优解最终求得大问题的最优解。那么对于一个序列而言，它的子问题是什么呢？很简单，序列是有长度的，所以我们可以通过序列的长度来划分子问题，如上序列所示，它有 <code>6</code> 个元素，即该序列的长度为 <code>6</code>，所以我们可不可以将这个序列拆解为长度更短的序列呢？并优先求解这些长度更短的序列的最长递增子序列，进而求得原序列的最长递增子序列？答案是肯定的，假设我们取出原序列的最后一个数字单独作为一个序列，那么该序列就只有一个元素：<code>[ 10 ]</code>，很显然这个只有一个元素的序列的长度为 <code>1</code>，已经不能更短了。那么序列 <code>[ 10 ]</code> 的最长递增子序列是什么呢？因为只有一个元素，所以毫无递增可言，但我们需要一个约定：<strong>当一个序列只有一个元素时，我们认为其递增子序列就是其本身</strong>，所以序列 <code>[ 10 ]</code> 的最长递增子序列也是 <code>[ 10 ]</code>，其长度也是 <code>1</code>。</p> <p>接着我们将子问题进行扩大，现在我们取出原序列中的最后两个数字作为一个序列，即 <code>[ 2, 10 ]</code>。对于这个序列而言，我们可以把它看作是<strong>由序列 <code>[ 2 ]</code> 和序列 <code>[ 10 ]</code> 这两个序列所组成的</strong>。并且我们观察这两个序列中的数字，发现满足条件 <code>2 &lt; 10</code>，这满足了递增的要求，所以我们是否可以认为<strong>序列 <code>[ 2, 10 ]</code> 的最长递增子序列等于序列 <code>[ 2 ]</code> 和序列 <code>[ 10 ]</code> 这两个序列的递增子序列“之和”</strong>？答案是肯定的，而且庆幸的是，我们在上一步中已经求得了序列 <code>[ 10 ]</code> 的最长递增子序列的长度是 <code>1</code>，同时序列 <code>[ 2 ]</code> 也是一个只有一个元素的序列，所以它的最长递增子序列也是它本身，长度也是 <code>1</code>，最后我们将两者做和，可知序列 <code>[ 2, 10 ]</code> 的最长递增子序列的长度应该是 <code>1 + 1 = 2</code>。实际上我们一眼就能够看得出来序列 <code>[ 2, 10 ]</code> 的最长递增子序列也是 <code>[ 2, 10 ]</code>，其长度当然为 <code>2</code> 啦。</p> <p>为了不过于抽象，我们可以画出如下图所示的格子：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis1.a175cde6.png" alt="img"></p> <p>我们为原序列中的每个数字分配一个格子，并且这些格子填充 <code>1</code> 作为初始值：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis2.af71d744.png" alt="img"></p> <p>根据前面的分析，我们分别求得子问题的序列 <code>[ 10 ]</code> 和 <code>[ 2, 10 ]</code> 的最长递增子序列的长度分别为 <code>1</code> 和 <code>2</code>，所以我们修改对应的格子中的值，如下：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis3.78ad38df.png" alt="img"></p> <p>如上图所示，原序列中数字 <code>10</code> 对应的格子的值依然是 <code>1</code>，因为序列 <code>[ 10 ]</code> 的最长递增子序列的长度是 <code>1</code>。而原序列中数字 <code>2</code> 对应的格子的值为 <code>2</code>，这是因为序列 <code>[ 2, 10 ]</code> 的最长递增子序列的长度是 <code>2</code>。所以你应该发现了格子中的值所代表的是<strong>以该格子所对应的数字为开头的递增子序列的最大长度</strong>。</p> <p>接下来我们继续扩大子问题，我们取出原序列中的最后三个数字作为子问题的序列：<code>[ 12, 2, 10 ]</code>。同样的，对于这个序列而言，我们可以把它看作是由序列 <code>[ 12 ]</code> 和序列 <code>[ 2, 10 ]</code> 这两个序列所组成的。但是我们发现条件 <code>12 &lt; 2</code> 并不成立，这说明什么呢？实际上这说明：<strong>以数字 <code>12</code> 开头的递增子序列的最大长度就 等于 以数字 <code>2</code> 开头的递增子序列的最大长度</strong>。这时我们不需要修改原序列中数字 <code>12</code> 所对应的格子的值，如下图所示该格子的值仍然是 <code>1</code>：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis4.aa68a822.png" alt="img"></p> <p>但是这就结束了吗？还不行，大家思考一下，刚刚我们的判断条件是 <code>12 &lt; 2</code>，这当然是不成立的，但大家不要忘了，序列 <code>[ 12, 2, 10 ]</code> 中数字 <code>2</code> 的后面还有一个数字 <code>10</code>，我们是否要继续判断条件 <code>12 &lt; 10</code> 是否成立呢？当然有必要，道理很简单，假设我们的序列是 <code>[ 12, 2, 15 ]</code> 的话，你会发现，如果仅仅判断条件 <code>12 &lt; 2</code> 是不够的，虽然数字 <code>12</code> 不能和数字 <code>2</code> 构成递增的关系，但是数字 <code>12</code> 却可以和数字 <code>15</code> 构成递增的关系，因此我们得出<strong>当填充一个格子的值时，我们应该拿当前格子对应的数字逐个与其后面的所有格子对应的数字进行比较</strong>，而不能仅仅与紧随其后的数字作比较。按照这个思路，我们继续判断条件 <code>12 &lt; 10</code> 是否成立，很显然是不成立的，所以原序列中数字 <code>12</code> 对应的格子的值仍然不需要改动，依然是 <code>1</code>。</p> <p>接着我们进一步扩大子问题，现在我们抽取原序列中最后的四个数字作为子问题的序列：<code>[ 4, 12, 2, 10 ]</code>。还是同样的思路，我们可以把这个序列看作是由序列 <code>[ 4 ]</code> 和序列 <code>[ 12, 2, 10 ]</code> 所组成的，又因为条件 <code>4 &lt; 12</code> 成立，因此我们可以认为子问题序列的最长递增子序列的长度等于<strong>序列 <code>[ 4 ]</code> 的最长递增子序列的长度与以数字 <code>12</code> 开头的递增子序列的最大长度之和</strong>，序列 <code>[ 4 ]</code> 的最长递增子序列的长度很显然是 <code>1</code>，而以数字 <code>12</code> 开头的递增子序列的最大长度实际上就是数字 <code>12</code> 对应的格子中的数值，我们在上一步已经求得这个值是 <code>1</code>，因此我们修改数字 <code>4</code> 对应的格子的值为 <code>1 + 1 = 2</code>：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis5.6891d76d.png" alt="img"></p> <p>当然了，着同样还没有结束，我们还要判断条件 <code>4 &lt; 2</code> 和 <code>4 &lt; 10</code> 是否成立，原因我们在前面已经分析过了。条件 <code>4 &lt; 2</code> 不成立，所以什么都不做，但条件 <code>4 &lt; 10</code> 成立，我们找到数字 <code>10</code> 对应的格子中的值：<code>1</code>，将这个值加 <code>1</code> 之后的值为 <code>2</code>，这与现在数字 <code>4</code> 对应的格子中的值相等，所以也不需要改动。</p> <p>到现在为止，不知道大家发现什么规律没有？如何计算一个格子中的值呢？实际很简单，规则是：</p> <ul><li>1、拿该格子对应的数字 <code>a</code> 与其后面的所有格子对应的数字 <code>b</code> 进行比较，如果条件 <code>a &lt; b</code> 成立，则用数字 <code>b</code> 对应格子中的值加 <code>1</code>，并将结果填充到数字 <code>a</code> 对应的格子中。</li> <li>2、只有当计算出来的值大于数字 <code>a</code> 所对应的格子中的值时，才需要更新格子中的数值。</li></ul> <p>有了这两条规则，我们就很容易填充剩余格子的值了，接下来我们来填充原序列中数字 <code>8</code> 所对应的格子的值。按照上面的分析，我们需要判断四个条件：</p> <ul><li><code>8 &lt; 4</code></li> <li><code>8 &lt; 12</code></li> <li><code>8 &lt; 2</code></li> <li><code>8 &lt; 10</code></li></ul> <p>很显然条件 <code>8 &lt; 4</code> 不成立，什么都不做；条件 <code>8 &lt; 12</code> 成立，拿出数字 <code>12</code> 对应格子中的值：<code>1</code>，为这个值再加 <code>1</code> 得出的值为 <code>2</code>，大于数字 <code>8</code> 对应格子的当前值，所以更新该格子的值为 <code>2</code>；条件 <code>8 &lt; 2</code> 也不成立，什么都不做；条件 <code>8 &lt; 10</code> 成立，拿出数字 <code>10</code> 对应格子中的值 <code>1</code>，为这个值再加 <code>1</code> 得出的值为 <code>2</code>，不大于数字 <code>8</code> 所对应格子中的值，所以什么都不需要做，最终我们为数字 <code>8</code> 所对应的格子填充的值是 <code>2</code>：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis6.188e964d.png" alt="img"></p> <p>现在，就剩下原序列中数字 <code>0</code> 对应的格子的值还没有被更新了，按照之前的思路，我们需要判断的条件如下：</p> <ul><li><code>0 &lt; 8</code></li> <li><code>0 &lt; 4</code></li> <li><code>0 &lt; 12</code></li> <li><code>0 &lt; 2</code></li> <li><code>0 &lt; 10</code></li></ul> <p>条件 <code>0 &lt; 8</code> 成立，拿出数字 <code>8</code> 对应格子中的值 <code>2</code>，为这个值再加 <code>1</code> 得出的值为 <code>3</code>，大于数字 <code>0</code> 对应格子的当前值，所以更新该格子的值为 <code>3</code>。重复执行上面介绍的步骤，最终原序列中数字 <code>0</code> 对应格子的值就是 <code>3</code>：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis7.4e6c0065.png" alt="img"></p> <p>如上图所示，现在所有格子的值都已经更新完毕，接下来我们要做的就是根据这些值，找到整个序列的最长递增子序列。那么应该如何寻找呢？很简单，实际上这些格子中的最大值就代表了整个序列的递增子序列的最大长度，上图中数字 <code>0</code> 对应格子的值为 <code>3</code>，是最大值，因此原序列的最长递增子序列一定是以数字 <code>0</code> 开头的：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis8.0fdc2268.png" alt="img"></p> <p>接着你需要在该值为 <code>3</code> 的格子后面的所有格子中寻找数值等于 <code>2</code> 的格子，你发现，有三个格子满足条件，分别是原序列中数字 <code>8</code>、<code>4</code>、<code>2</code> 所对应的格子。假设你选取的是数字 <code>4</code>：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis9.d98aa048.png" alt="img"></p> <p>同样的，你需要继续在数字 <code>4</code> 对应的格子后面的所有格子中寻找到数值为 <code>1</code> 的格子，你发现有两个格子是满足条件的，分别是原序列中数字 <code>12</code> 和数字 <code>10</code> 所对应的格子，我们再次随机选取一个值，假设我们选择的是数字 <code>10</code>：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis10.f667c339.png" alt="img"></p> <p>由于格子中的最小值就是数字 <code>1</code>，因此我们不需要继续寻找了。观察上图可以发现，我们选取出来的三个数字其实就是原序列的最长递增子序列：<code>[ 0, 4, 10 ]</code>。当然，你可能已经发现了，答案并非只有一个，例如：</p> <p><img src="http://hcysun.me/vue-design/assets/img/lis11.4c2ca168.png" alt="img"></p> <p>关键在于，有三个格子的数值是 <code>2</code>，因此你可以有三种选择：</p> <ul><li><code>[ 0, 8 ]</code></li> <li><code>[ 0, 4 ]</code></li> <li><code>[ 0, 2 ]</code></li></ul> <p>当你选择的是 <code>[ 0, 8 ]</code> 时，又因为数字 <code>8</code> 对应的格子后面的格子中，有两个数值为 <code>1</code> 的格子可供选择，所以你还有两种选择：</p> <ul><li><code>[ 0, 8, 12 ]</code></li> <li><code>[ 0, 8, 10 ]</code></li></ul> <p>同样的，如果你选择的是 <code>[ 0, 4 ]</code>，也有两个选择：</p> <ul><li><code>[ 0, 4, 12 ]</code></li> <li><code>[ 0, 4, 10 ]</code></li></ul> <p>但当你选择 <code>[ 0, 2 ]</code> 时，你就只有一个选择：</p> <ul><li><code>[ 0, 2, 10 ]</code></li></ul> <p>这是因为数字 <code>2</code> 所对应的格子后面，只有一个格子的数值是 <code>1</code>，即数字 <code>10</code> 所对应的那个格子，因此你只有一种选择。换句话说当你选择 <code>[ 0, 2 ]</code> 时，即使数字 <code>12</code> 对应的格子的值也是 <code>1</code>，你也不能选择它，因为数字 <code>12</code> 对应的格子在数字 <code>2</code> 对应的格子之前。</p> <p>以上，就是我们求得给定序列的<strong>所有</strong>最长递增子序列的算法。</p> <p>TIP</p> <p>上面的讲解中我们优先选择数值为 <code>3</code> 的格子，实际上我们也可以从小往大的选择，即先选择数值为 <code>1</code> 的格子，道理是一样。</p> <p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/32wjmo7omq</p> <p><a href="https://codesandbox.io/s/32wjmo7omq" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="不足之处"><a href="#不足之处" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 不足之处</h2> <p>实际上，我们确实花费了很大的篇幅来尽可能全面的讲解 <code>Virtual DOM</code> 核心的 <code>Diff</code> 算法，然而这里面仍然存在诸多不足之处，例如我们在移除一个 DOM 节点时，直接调用了 Web 平台的 <code>removeChild</code> 方法，这是因为在以上讲解中，我们始终假设新旧 <code>children</code> 中的 <code>VNode</code> 都是真实 DOM 的描述，而不包含组件的描述或其他类型 <code>VNode</code> 的描述，但实际上 <code>children</code> 中 <code>VNode</code> 的类型可以是任意的，因此我们不能简单的通过 Web 平台的 <code>removeChild</code> 方法进行 DOM 移除操作。这时我们需要封装一个专用函数：<code>removeVNode</code>，该函数专门负责移除一个 <code>VNode</code>，它会判断该 <code>VNode</code> 的类型，并采用合适的方式将其所渲染的真实 DOM 移除。大家思考一下，如果将要被移除的 <code>VNode</code> 是一个组件的描述，那是否还应该在移除之前或之后分别调用 <code>beforeUnmount</code> 以及 <code>unmounted</code> 等生命周期钩子函数呢？答案当然是肯定的。不过，本节讲解的内容虽然存在不足，但至少思路是完全正确的，在此基础上，你可以发挥自己的想象或者结合真正 <code>Vue3</code> 的源码去进一步的提升。</p> <h1 id="自定义渲染器和异步渲染"><a href="#自定义渲染器和异步渲染" class="header-anchor">#</a> 自定义渲染器和异步渲染</h1> <p>在本章之前，我们花费了很大的篇幅全面的讲解了一个普通渲染器的实现原理，它可以将 <code>Virtual DOM</code> 渲染为 Web 平台的真实 DOM。本章我们将在上一章的基础上讲解更加高级的渲染器：自定义渲染器(<code>Custom renderer</code>)以及异步渲染。</p> <h2 id="自定义渲染器的原理"><a href="#自定义渲染器的原理" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-advanced.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 自定义渲染器的原理</h2> <p>渲染器是围绕 <code>Virtual DOM</code> 而存在的，在 Web 平台下它能够把 <code>Virtual DOM</code> 渲染为浏览器中的真实 DOM 对象，通过前面几章的讲解，相信你已经能够认识到渲染器的实现原理，为了能够将 <code>Virtual DOM</code> 渲染为真实 DOM，渲染器内部需要调用浏览器提供的 DOM 编程接口，下面罗列了在出上一章中我们曾经使用到的那些浏览器为我们提供的 DOM 编程接口：</p> <ul><li><code>document.createElement / createElementNS</code>：创建标签元素。</li> <li><code>document.createTextNode</code>：创建文本元素。</li> <li><code>el.nodeValue</code>：修改文本元素的内容。</li> <li><code>el.removeChild</code>：移除 DOM 元素。</li> <li><code>el.insertBefore</code>：插入 DOM 元素。</li> <li><code>el.appendChild</code>：追加 DOM 元素。</li> <li><code>el.parentNode</code>：获取父元素。</li> <li><code>el.nextSibling</code>：获取下一个兄弟元素。</li> <li><code>document.querySelector</code>：挂载 <code>Portal</code> 类型的 <code>VNode</code> 时，用它查找挂载点。</li></ul> <p>这些 DOM 编程接口完成了 Web 平台(或者说浏览器)下对 DOM 的增加、删除、查找的工作，它是 Web  平台独有的，所以如果渲染器自身强依赖于这些方法(函数)，那么这个渲染器也只能够运行在浏览器中，它不具备跨平台的能力。换句话说，如果想要实现一个平台无关的渲染器，那么渲染器自身必须不能强依赖于任何一个平台下特有的接口，而是应该提供一个抽象层，将 “DOM”  的增加、删除、查找等操作使用抽象接口实现，具体到某个平台下时，由开发者决定如何使用该平台下的接口实现这个抽象层，这就是自定义渲染器的本质。</p> <p>TIP</p> <p>在下文中，我们将使用 “元素” 一词指代所有平台中的元素对象，例如在 Web 平台下 “元素” 一词指的就是 DOM 元素。</p> <p>渲染器除了负责对元素的增加、删除、查找之外，它还负责修改某个特定元素自身的属性/特性，例如 Web 平台中元素具有 <code>id</code>、<code>href</code> 等属性/特性。在上一章中，我们使用 <code>patchData</code> 函数来完成元素自身属性/特性的更新，如下代码用于修改一个元素的类名列表(<code>class</code>)：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// patchData.js</span>
<span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
  el<span class="token punctuation">.</span>className <span class="token operator">=</span> nextValue
  <span class="token keyword">break</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这段代码同样也只能运行在浏览器中，为了渲染器能够跨平台，那么修改一个元素自身的属性/特性的工作也应该作为可自定义的一部分才行，因此，一个跨平台的渲染器应该至少包含两个可自定义的部分：<strong>可自定义元素的增加、删除、查找等操作</strong>、<strong>可自定义元素自身属性/特性的修改操作</strong>。这样对于任何一个元素来说，它的增删改查都已经变成了可自定义的部分，我们只需要“告知”渲染器在对元素进行增删改查时应该做哪些具体的操作即可。</p> <p>接下来我们就着手将一个普通渲染器修改为拥有自定义能力的渲染器，在之前的讲解中，我们将渲染器的代码存放在了 <code>render.js</code> 文件中，如下是整个 <code>render.js</code> 文件的核心代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 导出渲染器</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token comment">// ========== 挂载 ==========</span>

<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mountText</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mountFragment</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mountPortal</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token comment">// ========== patch ==========</span>

<span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">patchText</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">patchFragment</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">patchPortal</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token comment">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span>
<span class="token keyword">function</span> <span class="token function">lis</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>观察如上代码结构，可以发现一个渲染器由两部分组成：<code>mount</code> 和 <code>patch</code>。在 <code>mount</code> 和 <code>patch</code> 中都会调用浏览器提供的 DOM 编程接口来完成真正的渲染工作。为了将浏览器提供的 DOM 编程接口与渲染器的代码分离，我们可以将如上代码封装到一个叫做 <code>createRenderer</code> 的函数中，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token comment">// ========== 挂载 ==========</span>

  <span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">mountText</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">mountFragment</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">mountPortal</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token comment">// ========== patch ==========</span>

  <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
    nextChildFlags<span class="token punctuation">,</span>
    prevChildren<span class="token punctuation">,</span>
    nextChildren<span class="token punctuation">,</span>
    container</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">patchText</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">patchFragment</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">patchPortal</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span>
<span class="token keyword">function</span> <span class="token function">lis</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><p><code>createRenderer</code> 函数的返回值就是之前的 <code>render</code> 函数，也就是说调用 <code>createRenderer</code> 函数可以创建一个渲染器。<code>createRenderer</code> 函数接收一个参数 <code>options</code>，该参数的作用是为了允许外界有能力将操作元素的具体实现以选项的方式传递进来。</p> <p>那么 <code>options</code> 参数中应该包含哪些选项呢？其实前面我们已经分析过了，只要是需要自定义的部分就应该作为选项传递进来，所以参数 <code>options</code> 中至少要包含两部分：一部分是元素的增加、删除、查找；另外一部分是元素的修改，即 <code>patchData</code> 函数。如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// nodeOps 是一个对象，该对象包含了所有用于操作节点的方法</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">createText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    <span class="token comment">// more...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  patchData
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>基于此，在 <code>createRenderer</code> 函数内部我们就可以通过解构的方式从 <code>options</code> 参数中得到具体的方法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// options.nodeOps 选项中包含了本章开头罗列的所有操作 DOM 的方法</span>
  <span class="token comment">// options.patchData 选项就是 patchData 函数</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>
    nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
      createElement<span class="token operator">:</span> platformCreateElement<span class="token punctuation">,</span>
      createText<span class="token operator">:</span> platformCreateText<span class="token punctuation">,</span>
      setText<span class="token operator">:</span> platformSetText<span class="token punctuation">,</span> <span class="token comment">// 等价于 Web 平台的 el.nodeValue</span>
      appendChild<span class="token operator">:</span> platformAppendChild<span class="token punctuation">,</span>
      insertBefore<span class="token operator">:</span> platformInsertBefore<span class="token punctuation">,</span>
      removeChild<span class="token operator">:</span> platformRemoveChild<span class="token punctuation">,</span>
      parentNode<span class="token operator">:</span> platformParentNode<span class="token punctuation">,</span>
      nextSibling<span class="token operator">:</span> platformNextSibling<span class="token punctuation">,</span>
      querySelector<span class="token operator">:</span> platformQuerySelector
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    patchData<span class="token operator">:</span> platformPatchData
  <span class="token punctuation">}</span> <span class="token operator">=</span> options

  <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token comment">// ========== 挂载 ==========</span>
  <span class="token comment">// 省略...</span>

  <span class="token comment">// ========== patch ==========</span>
  <span class="token comment">// 省略...</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>如上代码所示，<code>options.nodeOps</code> 选项是一个对象，它包含了所有用于对元素进行增、删、查的操作，<code>options.patchData</code> 选项是一个函数，用于处理某个特定元素上的属性/特定，这些内容都是在创建渲染器时由外界来决定的。</p> <p>接下来我们要做的就是将渲染器中原本使用了 Web 平台进行 DOM 操作的地方修改成使用通过解构得到的函数进行替代，例如在创建 DOM 元素时，原来的实现如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  isSVG <span class="token operator">=</span> isSVG <span class="token operator">||</span> vnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> isSVG
    <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
    <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>现在我们应该使用 <code>platformCreateElement</code> 函数替代 <code>document.createElement(NS)</code>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  isSVG <span class="token operator">=</span> isSVG <span class="token operator">||</span> vnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token function">platformCreateElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>类似的，其他所有涉及 DOM 操作的地方都应该使用这些通过解构得到的抽象接口替代。当这部分工作完成之后，接下来要做的就是对这些用于操作节点的抽象方法进行实现，如下代码所示，我们实现了 Web 平台下创建 DOM 节点的方法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> isSVG
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>再举一个例子，下面这条语句是我们之前实现的渲染器中用于移除旧 <code>children</code> 中节点的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>现在我们将之替换为 <code>platformRemoveChild</code> 函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">platformRemoveChild</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>为了让这段代码在 Web 平台正常工作，我们需要在创建渲染器时实现 <code>nodeOps.removeChild</code> 函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> isSVG
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>也许你已经想到了，当我们实现了所有 <code>nodeOps</code> 下的规定的抽象接口之后，实际上就完成了一个面向 Web 平台的渲染器，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> isSVG
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">setText</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> text
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> ref<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">parentNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span>parentNode
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">nextSibling</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span>nextSibling
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token parameter">selector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>当然了，如上代码所创建的渲染器只能够完成 Web 平台中对 DOM 的增加、删除和查找的功能，为了能够修改 DOM 元素自身的属性和特性，我们还需要在创建渲染器时将 <code>patchData</code> 函数作为选项传递过去，好在我们之前已经封装了 <code>patchData</code> 函数，现在直接拿过来用即可：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> patchData <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./patchData'</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  patchData
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>TIP</p> <p>完整代码&amp;在线体验地址：https://codesandbox.io/s/mq8v65qyry</p> <p><a href="https://codesandbox.io/s/mq8v65qyry" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>以上我们就完成了对渲染器的抽象，使它成为一个平台无关的工具。并基于此实现了一个 Web 平台的渲染器，专门用于浏览器环境。</p> <h2 id="自定义渲染器的应用"><a href="#自定义渲染器的应用" class="header-anchor">#</a> <a href="http://hcysun.me/vue-design/zh/renderer-advanced.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 自定义渲染器的应用</h2> <p><code>Vue3</code> 提供了一个叫做 <code>@vue/runtime-test</code> 的包，其作用是方便开发者在无 DOM 环境时有能力对组件的渲染内容进行测试，这实际上就是对自定义渲染器的应用。本节我们尝试来实现与 <code>@vue/runtime-test</code> 具有相同功能的渲染器。</p> <p>原理其实很简单，如下代码所示，这是用于 Web 平台下创建真实 DOM 元素的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> isSVG
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>其中 <code>nodeOps.createElement</code> 函数会返回一个真实的 DOM 对象，在其内部调用的是浏览器为我们提供的 <code>document.createElement/NS</code> 函数。实际上 <code>nodeOps.createElement</code> 函数的真正意图是：<strong>创建一个元素</strong>，然而并没有规定这个元素应该由谁来创建，或这个元素应该具有什么样的特征，这就是自定义的核心所在。因此，我们完全使 <code>nodeOps.createElement</code> 函数返回一个普通对象来代指一个元素，后续的所有操作都是基于我们所规定的元素而进行，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token operator">:</span> <span class="token string">'ELEMENT'</span><span class="token punctuation">,</span>
        tag
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> customElement
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在这段代码中，我们自行规定了 <code>nodeOps.createElement</code> 函数所返回的元素的格式，即 <code>customElement</code> 对象，它包含两个属性，分别是 用来代表元素类型的 <code>type</code> 属性以及用来代表元素名称的 <code>tag</code> 属性。虽然看上去很奇怪，但这确实是一个完全符合要求的实现。这么做的结果就是：<strong><code>nodeOps.createElement</code> 函数所创建的元素不来自于浏览器的 DOM 编程接口，更不来自于任何其他平台的 API</strong>，因此，如上代码所创建的渲染器也将是一个平台无关的渲染器。这就是为什么 <code>@vue/runtime-test</code> 可以运行在 <code>NodeJs</code> 中的原因。</p> <p>当然了，如上代码中 <code>customElement</code> 只有两个属性，实际上这并不能满足需求，即使元素的格式由我们自行定义，但还是要有一定的限制，例如元素会有子节点，子节点也需要保存对父节点的引用，元素自身也会有属性/特性等等。一个最小且完整的元素定义应该包含以下属性：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">,</span> <span class="token comment">// 元素的类型：ELEMENT ---&gt; 标签元素；TEXT ---&gt; 文本</span>
  tag<span class="token punctuation">,</span> <span class="token comment">// 当 type === 'ELEMENT' 时，tag 属性为标签名字</span>
  parentNode<span class="token punctuation">,</span> <span class="token comment">// 对父节点的引用</span>
  children<span class="token punctuation">,</span> <span class="token comment">// 子节点</span>
  props<span class="token punctuation">,</span>  <span class="token comment">// 当 type === 'ELEMENT' 时，props 中存储着元素的属性/特性</span>
  eventListeners<span class="token punctuation">,</span>  <span class="token comment">// 当 type === 'ELEMENT' 时，eventListeners 中存储着元素的事件信息</span>
  text  <span class="token comment">// 当 type === 'TEXT' 时，text 存储着文本内容</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>现在 <code>customElement</code> 就是一个能完全代替真实 DOM 对象的模拟实现了，我们用它修改之前的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token operator">:</span> <span class="token string">'ELEMENT'</span><span class="token punctuation">,</span>
        tag<span class="token punctuation">,</span>
        parentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        eventListeners<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        text<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> customElement
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>如上代码所示，由于 <code>nodeOps.createElement</code> 函数用于创建元素节点，因此 <code>type</code> 属性的值为 <code>'ELEMENT'</code>；刚刚创建的元素还不能确定其父节点，因此 <code>parentNode</code> 为 <code>null</code>；用于存储子节点的 <code>children</code> 属性被初始化为一个数组，<code>props</code> 属性和 <code>eventListeners</code> 被初始化为空对象；最后的 <code>text</code> 为 <code>null</code>，因为它不是一个文本节点。</p> <p>现在创建元素节点的功能已经实现，那么创建文本节点呢？如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span>
      <span class="token keyword">return</span> customElement
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token operator">:</span> <span class="token string">'TEXT'</span><span class="token punctuation">,</span>
        parentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        text<span class="token operator">:</span> text
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> customElement
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>文本元素的 <code>type</code> 类型值为 <code>'TEXT'</code>，<code>parentNode</code> 同样被初始化为 <code>unll</code>，<code>text</code> 属性存储着文本节点的内容。由于文本元素没有子节点、属性/特性、事件等信息，因此不需要其他描述信息。</p> <p>文本节点与元素节点的创建都已经实现，接下来我们看看当元素被追加时应该如何处理，即 <code>nodeOps.appendChild</code> 函数的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span>
      <span class="token keyword">return</span> customElement
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span>
      <span class="token keyword">return</span> customElement
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 简历父子关系</span>
      child<span class="token punctuation">.</span>parentNode <span class="token operator">=</span> parent
      parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>如上高亮代码所示，追加节点时我们要做的就是建立节点间正确的父子关系，在 Web 平台下，当我们调用 <code>el.appendChild</code> 函数时，父子关系是由浏览器负责建立的，但在模拟实现中，这个关系需要我们自己来维护。不过好在这很简单，让子元素的 <code>parentNode</code> 指向父元素，同时将子元素添加到父元素的 <code>children</code> 数组中即可。</p> <p>类似的，如下是 <code>nodeOps.removeChild</code> 函数的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 简历父子关系</span>
      child<span class="token punctuation">.</span>parentNode <span class="token operator">=</span> parent
      parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 找到将要移除的元素 child 在父元素的 children 中的位置</span>
      <span class="token keyword">const</span> i <span class="token operator">=</span> parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果找到了，则将其删除</span>
        parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 没找到，说明渲染器出了问题，例如没有在 nodeOps.appendChild 函数中维护正确的父子关系等</span>
        <span class="token comment">// 这时需要打印错误信息，以提示开发者</span>
        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'target: '</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'parent: '</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">'target 不是 parent 的子节点'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 清空父子链</span>
      child<span class="token punctuation">.</span>parentNode <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>如上高亮代码所示，在移除节点时，思路也很简单，首先需要在父节点的 <code>children</code> 属性中查找即将要被移除的节点的位置索引，如果找到了，那么就直接将其从父节点的 <code>children</code> 数组中移除即可。如果没有找到则说明渲染器出问题了，例如在你实现自定义渲染器时没有在 <code>nodeOps.appendChild</code> 函数或 <code>nodeOps.insertBefore</code> 函数中维护正确的父子关系，这时我们需要打印错误信息以提示开发者。最后不要忘记清空父子链。</p> <p>通过如上的讲解，你可能已经领会到了，我们所做的其实就是在模拟 Web 平台在操作元素时的行为，并且这个模拟的思路也及其简单。实际上，当我们实现了所有 <code>nodeOps</code> 下的抽象函数之后，那么这个类似于 <code>@vue/runtime-test</code> 的自定义渲染器就基本完成了。当然，不要忘记的是我们还需要实现 <code>patchData</code> 函数，这可能比你想象的要简单的多，如下高亮代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span>
    <span class="token comment">// 其他 nodeOps 函数的实现</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">patchData</span><span class="token punctuation">(</span>
    <span class="token parameter">el<span class="token punctuation">,</span>
    key<span class="token punctuation">,</span>
    prevValue<span class="token punctuation">,</span>
    nextValue</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将属性添加到元素的 props 对象下</span>
    el<span class="token punctuation">.</span>props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue
    <span class="token comment">// 我们将属性名字中前两个字符是 'o' 和 'n' 的属性认为是事件绑定</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'o'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果是事件，则将事件添加到元素的 eventListeners 对象下</span>
      <span class="token keyword">const</span> event <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">;</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>eventListeners <span class="token operator">||</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>eventListeners <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>在创建渲染器时我们需要实现 <code>patchData</code> 函数的功能，它的功能是用来更新元素自身的属性/特性的，在之前的讲解中我们实现了 Web 平台中 <code>patchData</code> 函数，然而在这个模拟实现中，我们要做的事情就少了很多。只需要把元素的属性添加到元素的 <code>props</code> 对象中即可，同时如果是事件的话，我们也只需要将其添加到元素的 <code>eventListeners</code> 对象中就可以了。</p> <p>实际上，本节我们所实现的自定义渲染器，就能够满足我们对组件测试的需求，我们可以利用它来测试组件所渲染内容的正确性。如果你想要进一步提升该自定义渲染器的能力，例如希望该渲染器有能力在控制台中打印出操作元素的信息，也很简单，我们以创建元素为例，如下代码所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token operator">:</span> <span class="token string">'ELEMENT'</span><span class="token punctuation">,</span>
        tag<span class="token punctuation">,</span>
        parentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        eventListeners<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        text<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span>

      console<span class="token punctuation">.</span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        type<span class="token operator">:</span> <span class="token string">'CREATE ELEMENT'</span><span class="token punctuation">,</span>
        targetNode<span class="token operator">:</span> customElement
      <span class="token punctuation">}</span><span class="token punctuation">)</span>

      <span class="token keyword">return</span> customElement
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>只需要在 <code>nodeOps.createElement</code> 函数中调用 <code>console.table</code> 进行打印你想要的信息即可，例如我们打印了一个对象，该对象包含 <code>type</code> 属性用于指示当前操作元素的类型，所以对于创建元素来说，我们为 <code>type</code> 属性赋值了字符串 <code>'CREATE ELEMENT'</code>，同时将目标节点也打印了出来(即 <code>targetNode</code>)。类似的，追加节点可以打印如下信息：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 简历父子关系</span>
      child<span class="token punctuation">.</span>parentNode <span class="token operator">=</span> parent
      parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>

      console<span class="token punctuation">.</span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        type<span class="token operator">:</span> <span class="token string">'APPEND'</span><span class="token punctuation">,</span>
        targetNode<span class="token operator">:</span> child<span class="token punctuation">,</span>
        parentNode<span class="token operator">:</span> parent
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>怎么样，是不是很简单。当然了这只是自定义渲染器的应用之一，对于自定义渲染器来说，它可发挥的空间还是非常大的，举几个例子：</p> <ul><li>渲染到 <code>PDF</code>，我们可以实现一个自定义渲染器如 <code>vue-pdf-renderer</code>，它能够将 <code>Vue</code> 组件渲染为 <code>PDF</code> 文件。</li> <li>渲染到文件系统，我们可以实现一个 <code>vue-file-renderer</code>，它可以根据 <code>VNode</code> 的结构在本地渲染与该结构相同的文件目录。</li> <li><code>canvas</code> 渲染器，我们可以实现一个 <code>vue-canvas-renderer</code>，它可以从渲染器的层面渲染 <code>canvas</code>，而非组件层面。</li></ul></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----></main> <!----> <div class="comments-wrapper" data-v-4698c43e><div class="valine-wrapper"><div id="valine"></div></div></div></div></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-a81d141e data-v-a81d141e><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-a81d141e><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-a81d141e></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-a81d141e></path></svg></div><canvas id="vuepress-canvas-ribbon"></canvas><div class="kanbanniang" data-v-5775ee02><div class="banniang-container" style="display:;" data-v-5775ee02><div class="messageBox" style="right:68px;bottom:190px;display:none;" data-v-5775ee02>
      欢迎来到 叫我詹躲躲
    </div> <div class="operation" style="right:90px;bottom:40px;display:;" data-v-5775ee02><i class="kbnfont kbn-ban-home ban-home" data-v-5775ee02></i> <i class="kbnfont kbn-ban-message message" data-v-5775ee02></i> <i class="kbnfont kbn-ban-close close" data-v-5775ee02></i> <a target="_blank" href="https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html" data-v-5775ee02><i class="kbnfont kbn-ban-info info" data-v-5775ee02></i></a> <i class="kbnfont kbn-ban-theme skin" style="display:none;" data-v-5775ee02></i></div> <canvas id="banniang" width="150" height="220" class="live2d" style="position:fixed;right:80px;bottom:0;opacity:0.9;z-index:99999;height:300px;" data-v-5775ee02></canvas></div> <div class="showBanNiang" style="display:none;" data-v-5775ee02>
    看板娘
  </div></div><div class="reco-bgm-panel" data-v-128600c6><audio id="bgm" src="./平凡之路.mp3" data-v-128600c6></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-128600c6 data-v-41bcba48 data-v-128600c6><img src="./平凡之路.jpg" data-v-128600c6></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-128600c6 data-v-41bcba48 data-v-128600c6><div class="reco-bgm-cover" style="background-image:url(./平凡之路.jpg);" data-v-128600c6><div class="mini-operation" style="display:none;" data-v-128600c6><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-128600c6></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-128600c6></i></div> <div class="falut-message" style="display:none;" data-v-128600c6>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-128600c6 data-v-41bcba48 data-v-128600c6><div class="info-box" data-v-128600c6><i class="reco-bgm reco-bgm-music music" data-v-128600c6></i>平凡之路</div> <div class="info-box" data-v-128600c6><i class="reco-bgm reco-bgm-artist" data-v-128600c6></i>朴树</div> <div class="reco-bgm-progress" data-v-128600c6><div class="progress-bar" data-v-128600c6><div class="bar" data-v-128600c6></div></div></div> <div class="reco-bgm-operation" data-v-128600c6><i class="reco-bgm reco-bgm-last last" data-v-128600c6></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-128600c6></i> <i class="reco-bgm reco-bgm-play play" data-v-128600c6></i> <i class="reco-bgm reco-bgm-next next" data-v-128600c6></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-128600c6></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-128600c6></i> <div class="volume-bar" data-v-128600c6><div class="bar" data-v-128600c6></div></div></div></div> <div class="reco-bgm-left-box" data-v-128600c6 data-v-41bcba48 data-v-128600c6><i class="reco-bgm reco-bgm-left" data-v-128600c6></i></div></div></div><canvas id="vuepress-canvas-cursor"></canvas><div></div><div id="goTop" class="hide-cat" data-v-3cd57a9e></div></div></div>
    <script src="/assets/js/app.86b73e6f.js" defer></script><script src="/assets/js/3.58a7fd54.js" defer></script><script src="/assets/js/1.4b4254a2.js" defer></script><script src="/assets/js/31.8e9e1642.js" defer></script>
  </body>
</html>
